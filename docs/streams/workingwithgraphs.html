<!DOCTYPE html>
<!--[if IE 8]>			<html class="ie ie8"> <![endif]-->
<!--[if IE 9]>			<html class="ie ie9"> <![endif]-->
<!--[if gt IE 9]><!-->	<html> <!--<![endif]-->
	<head>
		

<meta charset="utf-8" />
<title>Working with Graphs | Akka.NET</title>

<meta name="keywords" content="Actor,Finite state machine, concurrency" />
<meta name="description" content="" />
<meta name="Author" content="Dorin Grigoras [www.stepofweb.com]" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />

<!-- mobile settings -->
<meta name="viewport" contenht="width=device-width, maximum-scale=1, initial-scale=1, user-scalable=0" />

<!-- Favicon -->
<link rel="shortcut icon" href="/theme_assets/images/demo/favicon.ico" />

<!-- WEB FONTS -->
<link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,700,800&amp;subset=latin,latin-ext" rel="stylesheet" type="text/css" />

<!-- CORE CSS -->
<link href="/theme_assets/plugins/bootstrap/css/bootstrap.min.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/font-awesome.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/sky-forms.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/weather-icons.min.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/line-icons.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/plugins/owl-carousel/owl.pack.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/plugins/magnific-popup/magnific-popup.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/animate.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/flexslider.css" rel="stylesheet" type="text/css" />

<!-- FAV ICON -->
<link rel="shortcut icon" href="http://akkadotnet.github.io/favicon.ico?v=2" />

<!-- REVOLUTION SLIDER -->
<link href="/theme_assets/css/revolution-slider.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/layerslider.css" rel="stylesheet" type="text/css" />

<!-- BLOG -->
<link href="/theme_assets/css/layout-blog.css" rel="stylesheet" type="text/css" />

<!-- THEME CSS -->
<link href="/theme_assets/css/essentials.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/layout.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/header-default.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/footer-default.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/color_scheme/red.css" rel="stylesheet" type="text/css" id="color_scheme" />

<!-- Highlighting -->
<link href="https://highlightjs.org/static/demo/styles/github.css" rel="stylesheet" type="text/css" />
<link href="/css/screen.css" rel="stylesheet" type="text/css" />

<!-- Modernizr -->
<script type="text/javascript" src="/theme_assets/plugins/modernizr.min.js"></script>

<!--[if lte IE 8]>
  <script src="/theme_assets/plugins/respond.js"></script>
<![endif]-->

	</head>

	<!--
		Available body classes:
			smoothscroll			= enable chrome browser smooth scroll
			grey 					= grey content background
			boxed 					= boxed style
			pattern1 ... pattern10 	= background pattern

		Background Image - add to body:
			data-background="/theme_assets/images/boxed_background/1.jpg"
	-->
	<body class=" ">

		<div id="wrapper">
			<div id="header">
  <header id="topBar">
    <div class="container">

      

      <!-- Logo -->
      <a class="logo" href="/">
        <img src="/images/akkalogo.png"  alt="" style="padding-top:0px;padding-left: 5px;" />
      </a>

    </div><!-- /.container -->
  </header>
  <div id="topNav">
  <div class="container">
    <!-- Mobile Menu Button -->
    <button class="btn btn-mobile" data-toggle="collapse" data-target=".nav-main-collapse">
      <i class="fa fa-bars"></i>
    </button>

    <!-- Search -->
    <form class="search" method="get" action="/search">
      <input type="text" class="form-control" name="q" value="" placeholder="Search">
      <button class="fa fa-search"></button>
    </form>
    <!-- /Search -->

    <!-- Top Nav -->
    <div class="navbar-collapse nav-main-collapse collapse inline-block">
      <nav class="nav-main">

      

        <!-- pageurl  -->
        <ul id="topMain" class="nav nav-pills nav-main">
          <li class="mega-menu  active">
            <a href="/docs/">DOCUMENTATION<span>&nbsp;</span></a>
          </li>
          <li class="mega-menu">
            <a href="https://github.com/akkadotnet/akka.net/">CODE<span>&nbsp;</span></a>
          </li>
          <li class="mega-menu">
            <a href="https://gitter.im/akkadotnet/akka.net">PROJECT CHAT<span>&nbsp;</span></a>
          </li>
          <li class="mega-menu">
            <a href="https://groups.google.com/forum/#!forum/akkadotnet-user-list">MAILING LIST<span>&nbsp;</span></a>
          </li>
          <li class="mega-menu ">
            <a href="/pages/support">COMMERCIAL SUPPORT<span>&nbsp;</span></a>
          </li>
          <li class="mega-menu ">
            <a href="/docs/Resources">RESOURCES<span>&nbsp;</span></a>
          </li>
        </ul>

      </nav>
    </div>
</div>
</div>
			

			<!-- PAGE TOP -->
			<section class="page-title">
				<div class="container">
					<header>
						<ul class="breadcrumb"><!-- breadcrumb -->
							<li><a href="/">Home</a></li>
							<li><a href="/docs/">Docs</a></li>
							<li class="active">Working with Graphs<a href="https://github.com/akkadotnet/getakka.net/edit/master/src/docs/workingwithgraphs.md" > (Edit on Github)</a></li>
						</ul><!-- /breadcrumb -->

						<h2><!-- Page Title -->
							<strong>Akka.NET</strong> Docs
						</h2><!-- /Page Title -->

					</header>

				</div>
			</section>
			<!-- /PAGE TOP -->

			<!-- CONTENT -->
			<section>
				<div class="container">

					<div class="row">

						<!-- RIGHT COLUMNS -->
						<div class="col-md-3" id="toc">
						</div>
						<!-- /RIGHT COLUMNS -->

						<!-- LEFT COLUMNS -->
						<div class="col-md-8 docs-content">
							<div id="main_content">

								<div><p>In Akka Streams computation graphs are not expressed using a fluent DSL like linear computations are, instead they are
written in a more graph-resembling DSL which aims to make translating graph drawings (e.g. from notes taken
from design discussions, or illustrations in protocol specifications) to and from code simpler. In this section we’ll
dive into the multiple ways of constructing and re-using graphs, as well as explain common pitfalls and how to avoid them.</p>
<p>Graphs are needed whenever you want to perform any kind of fan-in (&quot;multiple inputs&quot;) or fan-out (&quot;multiple outputs&quot;) operations.
Considering linear Flows to be like roads, we can picture graph operations as junctions: multiple flows being connected at a single point.
Some graph operations which are common enough and fit the linear style of Flows, such as <code>Concat</code> (which concatenates two
streams, such that the second one is consumed after the first one has completed), may have shorthand methods defined on
<code>Flow</code> or <code>Source</code> themselves, however you should keep in mind that those are also implemented as graph junctions.</p>
<h1 id="constructing-graphs">Constructing Graphs</h1>
<p>Graphs are built from simple Flows which serve as the linear connections within the graphs as well as junctions
which serve as fan-in and fan-out points for Flows. Thanks to the junctions having meaningful types based on their behaviour
and making them explicit elements these elements should be rather straightforward to use.</p>
<p>Akka Streams currently provide these junctions (for a detailed list see <a href="builtinstages">Overview of built-in stages and their semantics</a>):</p>
<ul>
<li><p><strong>Fan-out</strong></p>
<ul>
<li><code>Broadcast&lt;T&gt;</code> – <em>(1 input, N outputs)</em> given an input element emits to each output</li>
<li><code>Balance&lt;T&gt;</code> – <em>(1 input, N outputs)</em> given an input element emits to one of its output ports</li>
<li><code>UnzipWith&lt;In,A,B,...&gt;</code> – <em>(1 input, N outputs)</em> takes a function of 1 input that given a value for each input emits N output elements (where N &lt;= 20)</li>
<li><code>UnZip&lt;A,B&gt;</code> – <em>(1 input, 2 outputs)</em> splits a stream of <code>(A,B)</code> tuples into two streams, one of type <code>A</code> and one of type <code>B</code>   </li>
</ul>
</li>
<li><p><strong>Fan-in</strong></p>
<ul>
<li><code>Merge&lt;In&gt;</code> – <em>(N inputs , 1 output)</em> picks randomly from inputs pushing them one by one to its output</li>
<li><code>MergePreferred&lt;In&gt;</code> – like <code>Merge</code> but if elements are available on <code>preferred</code> port, it picks from it, otherwise randomly from <code>others</code></li>
<li><code>ZipWith&lt;A,B,...,Out&gt;</code> – <em>(N inputs, 1 output)</em> which takes a function of N inputs that given a value for each input emits 1 output element</li>
<li><code>Zip&lt;A,B&gt;</code> – <em>(2 inputs, 1 output)</em> is a <code>ZipWith</code> specialised to zipping input streams of <code>A</code> and <code>B</code> into an <code>(A,B)</code> tuple stream</li>
<li><code>Concat&lt;A&gt;</code> – <em>(2 inputs, 1 output)</em> concatenates two streams (first consume one, then the second one)</li>
</ul>
</li>
</ul>
<p>One of the goals of the GraphDSL DSL is to look similar to how one would draw a graph on a whiteboard, so that it is
simple to translate a design from whiteboard to code and be able to relate those two. Let&#39;s illustrate this by translating
the below hand drawn graph into Akka Streams:</p>
<p><img class="img-responsive" src="../images/simple-graph-example.png" alt="SimpleGraphExample"></p>
<p>Such graph is simple to translate to the Graph DSL since each linear element corresponds to a <code>Flow</code>,
and each circle corresponds to either a <code>Junction</code> or a <code>Source</code> or <code>Sink</code> if it is beginning
or ending a <code>Flow</code>. Junctions must always be created with defined type parameters.  </p>
<pre><code class="hljs lang-csharp"><span class="hljs-keyword">var</span> g = RunnableGraph.FromGraph(GraphDsl.Create(builder =&gt;
{
    <span class="hljs-keyword">var</span> source = Source.From(Enumerable.Range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>));
    <span class="hljs-keyword">var</span> sink = Sink.Ignore&lt;<span class="hljs-keyword">int</span>&gt;().MapMaterializedValue(_ =&gt; NotUsed.Instance);

    <span class="hljs-keyword">var</span> broadcast = builder.Add(<span class="hljs-keyword">new</span> Broadcast&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));
    <span class="hljs-keyword">var</span> merge = builder.Add(<span class="hljs-keyword">new</span> Merge&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));

    <span class="hljs-keyword">var</span> f1 = Flow.Create&lt;<span class="hljs-keyword">int</span>&gt;().Select(x =&gt; x + <span class="hljs-number">10</span>);
    <span class="hljs-keyword">var</span> f2 = Flow.Create&lt;<span class="hljs-keyword">int</span>&gt;().Select(x =&gt; x + <span class="hljs-number">10</span>);
    <span class="hljs-keyword">var</span> f3 = Flow.Create&lt;<span class="hljs-keyword">int</span>&gt;().Select(x =&gt; x + <span class="hljs-number">10</span>);
    <span class="hljs-keyword">var</span> f4 = Flow.Create&lt;<span class="hljs-keyword">int</span>&gt;().Select(x =&gt; x + <span class="hljs-number">10</span>);

    builder.From(source).Via(f1).Via(broadcast).Via(f2).Via(merge).Via(f3).To(sink);
    builder.From(broadcast).Via(f4).To(merge);

    <span class="hljs-keyword">return</span> ClosedShape.Instance;
}));
</code></pre>
<div class="alert alert-default">
<p><strong>Note</strong><br/>
Junction <em>reference equality</em> defines <em>graph node equality</em> (i.e. the same merge <em>instance</em> used in a GraphDSL
refers to the same location in the resulting graph).</p>
</div>
<p>By looking at the snippets above, it should be apparent that the <code>GraphDSL.Builder</code> object is <em>mutable</em>.
The reason for this design choice is to enable simpler creation of complex graphs, which may even contain cycles.
Once the GraphDSL has been constructed though, the <code>GraphDSL</code> instance <em>is immutable, thread-safe, and freely shareable</em>.
The same is true of all graph pieces—sources, sinks, and flows—once they are constructed.
This means that you can safely re-use one given Flow or junction in multiple places in a processing graph.</p>
<p>We have seen examples of such re-use already above: the merge and broadcast junctions were imported
into the graph using <code>builder.Add(...)</code>, an operation that will make a copy of the blueprint that
is passed to it and return the inlets and outlets of the resulting copy so that they can be wired up.
Another alternative is to pass existing graphs—of any shape—into the factory method that produces a
new graph. The difference between these approaches is that importing using <code>builder.Add(...)</code> ignores the
materialized value of the imported graph while importing via the factory method allows its inclusion;
for more details see <a href="basics#stream-materialization">Stream Materialization</a>.</p>
<p>In the example below we prepare a graph that consists of two parallel streams,
in which we re-use the same instance of <code>Flow</code>, yet it will properly be
materialized as two connections between the corresponding Sources and Sinks:</p>
<pre><code class="hljs lang-csharp"><span class="hljs-keyword">var</span> topHeadSink = Sink.First&lt;<span class="hljs-keyword">int</span>&gt;();
<span class="hljs-keyword">var</span> bottomHeadSink = Sink.First&lt;<span class="hljs-keyword">int</span>&gt;();
<span class="hljs-keyword">var</span> sharedDoubler = Flow.Create&lt;<span class="hljs-keyword">int</span>&gt;().Select(x =&gt; x*<span class="hljs-number">2</span>);

RunnableGraph.FromGraph(GraphDsl.Create(topHeadSink, bottomHeadSink, Keep.Both,
    (builder, topHs, bottomHs) =&gt;
    {
        <span class="hljs-keyword">var</span> broadcast = builder.Add(<span class="hljs-keyword">new</span> Broadcast&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));
        <span class="hljs-keyword">var</span> source = Source.Single(<span class="hljs-number">1</span>).MapMaterializedValue&lt;Tuple&lt;Task&lt;<span class="hljs-keyword">int</span>&gt;, Task&lt;<span class="hljs-keyword">int</span>&gt;&gt;&gt;(_ =&gt; <span class="hljs-keyword">null</span>);

        builder.From(source).To(broadcast.In);

        builder.From(broadcast.Out(<span class="hljs-number">0</span>)).Via(sharedDoubler).To(topHs.Inlet);
        builder.From(broadcast.Out(<span class="hljs-number">1</span>)).Via(sharedDoubler).To(bottomHs.Inlet);

        <span class="hljs-keyword">return</span> ClosedShape.Instance;
    }));
</code></pre>
<h1 id="constructing-and-combining-partial-graphs">Constructing and combining Partial Graphs</h1>
<p>Sometimes it is not possible (or needed) to construct the entire computation graph in one place, but instead construct all of its different phases in different places and in the end connect them all into a complete graph and run it.</p>
<p>This can be achieved by returning a different <code>Shape</code> than <code>ClosedShape</code>, for example <code>FlowShape(in, out)</code>, from the
function given to <code>GraphDSL.Create</code>. See  <a href="#predefined-shapes">Predefined shapes</a> for a list of such predefined shapes.</p>
<p>Making a <code>Graph</code> a <code>RunnableGraph</code> requires all ports to be connected, and if they are not
it will throw an exception at construction time, which helps to avoid simple
wiring errors while working with graphs. A partial graph however allows
you to return the set of yet to be connected ports from the code block that
performs the internal wiring.</p>
<p>Let&#39;s imagine we want to provide users with a specialized element that given 3 inputs will pick
the greatest int value of each zipped triple. We&#39;ll want to expose 3 input ports (unconnected sources) and one output port (unconnected sink).</p>
<pre><code class="hljs lang-csharp"><span class="hljs-keyword">var</span> pickMaxOfThree = GraphDsl.Create(b =&gt;
{
    <span class="hljs-keyword">var</span> zip1 = b.Add(ZipWith.Apply&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(Math.Max));
    <span class="hljs-keyword">var</span> zip2 = b.Add(ZipWith.Apply&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(Math.Max));
    b.From(zip1.Out).To(zip2.In0);

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UniformFanInShape&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(zip2.Out, zip1.In0, zip1.In1, zip2.In1);
});

<span class="hljs-keyword">var</span> resultSink = Sink.First&lt;<span class="hljs-keyword">int</span>&gt;();

<span class="hljs-keyword">var</span> g = RunnableGraph.FromGraph(GraphDsl.Create(resultSink, (b, sink) =&gt;
{
    <span class="hljs-comment">// importing the partial graph will return its shape (inlets &amp; outlets)</span>
    <span class="hljs-keyword">var</span> pm3 = b.Add(pickMaxOfThree);
    <span class="hljs-keyword">var</span> s1 = Source.Single(<span class="hljs-number">1</span>).MapMaterializedValue&lt;Task&lt;<span class="hljs-keyword">int</span>&gt;&gt;(_ =&gt; <span class="hljs-keyword">null</span>);
    <span class="hljs-keyword">var</span> s2 = Source.Single(<span class="hljs-number">2</span>).MapMaterializedValue&lt;Task&lt;<span class="hljs-keyword">int</span>&gt;&gt;(_ =&gt; <span class="hljs-keyword">null</span>);
    <span class="hljs-keyword">var</span> s3 = Source.Single(<span class="hljs-number">3</span>).MapMaterializedValue&lt;Task&lt;<span class="hljs-keyword">int</span>&gt;&gt;(_ =&gt; <span class="hljs-keyword">null</span>);

    b.From(s1).To(pm3.In(<span class="hljs-number">0</span>));
    b.From(s2).To(pm3.In(<span class="hljs-number">1</span>));
    b.From(s3).To(pm3.In(<span class="hljs-number">2</span>));

    b.From(pm3.Out).To(sink.Inlet);

    <span class="hljs-keyword">return</span> ClosedShape.Instance;
}));

<span class="hljs-keyword">var</span> max = g.Run(materializer);
max.Wait(TimeSpan.FromSeconds(<span class="hljs-number">3</span>)).Should().BeTrue();
max.Result.Should().Be(<span class="hljs-number">3</span>);
</code></pre>
<p>As you can see, first we construct the partial graph that contains all the zipping and comparing of stream
elements. This partial graph will have three inputs and one output, wherefore we use the <code>UniformFanInShape</code>.
Then we import it (all of its nodes and connections) explicitly into the closed graph built in the second step in which all the undefined elements are rewired to real sources and sinks. The graph can then be run and yields the expected result.</p>
<div class="alert alert-warning">
<p><strong>Warning</strong><br/>
Please note that <code>GraphDSL</code> is not able to provide compile time type-safety about whether or not all elements have been properly connected—this validation is performed as a runtime check during the graph&#39;s instantiation. A partial graph also verifies that all ports are either connected or part of the returned <code>Shape</code>.</p>
</div>
<h1 id="constructing-sources-sinks-and-flows-from-partial-graphs">Constructing Sources, Sinks and Flows from Partial Graphs</h1>
<p>Instead of treating a partial graph as simply a collection of flows and junctions which may not yet all be
connected it is sometimes useful to expose such a complex graph as a simpler structure,
such as a <code>Source</code>, <code>Sink</code> or <code>Flow</code>.</p>
<p>In fact, these concepts can be easily expressed as special cases of a partially connected graph:</p>
<ul>
<li><code>Source</code> is a partial graph with <em>exactly one</em> output, that is it returns a <code>SourceShape</code>.</li>
<li><code>Sink</code> is a partial graph with <em>exactly one</em> input, that is it returns a <code>SinkShape</code>.</li>
<li><code>Flow</code> is a partial graph with <em>exactly one</em> input and <em>exactly one</em> output, that is it returns a <code>FlowShape</code>.</li>
</ul>
<p>Being able to hide complex graphs inside of simple elements such as Sink / Source / Flow enables you to easily create one complex element and from there on treat it as simple compound stage for linear computations.</p>
<p>In order to create a Source from a graph the method <code>Source.fromGraph</code> is used, to use it we must have a
<code>IGraph&lt;SourceShape, T&gt;</code>. This is constructed using <code>GraphDSL.Create</code> and returning a <code>SourceShape</code>
from the function passed in . The single outlet must be provided to the <code>SourceShape.Of</code> method and will become “the sink that must be attached before this Source can run”.</p>
<p>Refer to the example below, in which we create a Source that zips together two numbers, to see this graph
construction in action:</p>
<pre><code class="hljs lang-csharp"><span class="hljs-keyword">var</span> pairs = Source.FromGraph(GraphDsl.Create(b =&gt;
{
    <span class="hljs-comment">// prepare graph elements</span>
    <span class="hljs-keyword">var</span> zip = b.Add(<span class="hljs-keyword">new</span> Zip&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;());
    Func&lt;Source&lt;<span class="hljs-keyword">int</span>, Task&lt;Tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&gt;&gt; ints = () =&gt;
        Source.From(Enumerable.Range(<span class="hljs-number">1</span>, <span class="hljs-keyword">int</span>.MaxValue))
            .MapMaterializedValue&lt;Task&lt;Tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&gt;(_ =&gt; <span class="hljs-keyword">null</span>);

    <span class="hljs-comment">// connect the graph</span>
    b.From(ints().Where(x =&gt; x%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>)).To(zip.In0);
    b.From(ints().Where(x =&gt; x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)).To(zip.In1);

    <span class="hljs-comment">// expose port</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SourceShape&lt;Tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;(zip.Out);
}));

<span class="hljs-keyword">var</span> firstPair = pairs.RunWith(Sink.First&lt;Tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;(), materializer);
</code></pre>
<p>Similarly the same can be done for a <code>Sink&lt;T&gt;</code>, using <code>SinkShape.Of</code> in which case the provided value
must be an <code>Inlet&lt;T&gt;</code>. For defining a <code>Flow&lt;T&gt;</code> we need to expose both an inlet and an outlet:</p>
<pre><code class="hljs lang-csharp"><span class="hljs-keyword">var</span> pairUpWithToString = Flow.FromGraph(
    GraphDsl.Create(b =&gt;
    {
        <span class="hljs-comment">// prepare graph elements</span>
        <span class="hljs-keyword">var</span> broadcast = b.Add(<span class="hljs-keyword">new</span> Broadcast&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));
        <span class="hljs-keyword">var</span> zip = b.Add(<span class="hljs-keyword">new</span> Zip&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">string</span>&gt;());

        <span class="hljs-comment">// connect the graph</span>
        b.From(broadcast.Out(<span class="hljs-number">0</span>)).Via(Flow.Create&lt;<span class="hljs-keyword">int</span>&gt;().Select(x =&gt; x)).To(zip.In0);
        b.From(broadcast.Out(<span class="hljs-number">1</span>)).Via(Flow.Create&lt;<span class="hljs-keyword">int</span>&gt;().Select(x =&gt; x.ToString())).To(zip.In1);

        <span class="hljs-comment">// expose ports</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FlowShape&lt;<span class="hljs-keyword">int</span>, Tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">string</span>&gt;&gt;(broadcast.In, zip.Out);
    }));

pairUpWithToString.RunWith(Source.From(<span class="hljs-keyword">new</span>[] {<span class="hljs-number">1</span>}), Sink.First&lt;Tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">string</span>&gt;&gt;(), materializer);
</code></pre>
<h1 id="combining-sources-and-sinks-with-simplified-api">Combining Sources and Sinks with simplified API</h1>
<p>There is a simplified API you can use to combine sources and sinks with junctions like: <code>Broadcast&lt;T&gt;</code>, <code>Balance&lt;T&gt;</code>,  <code>Merge&lt;In&gt;</code> and <code>Concat&lt;A&gt;</code> without the need for using the Graph DSL. The combine method takes care of constructing the necessary graph underneath. In following example we combine two sources into one (fan-in):</p>
<pre><code class="hljs lang-csharp"><span class="hljs-keyword">var</span> sourceOne = Source.Single(<span class="hljs-number">1</span>);
<span class="hljs-keyword">var</span> sourceTwo = Source.Single(<span class="hljs-number">2</span>);
<span class="hljs-keyword">var</span> merged = Source.Combine(sourceOne, sourceTwo, i =&gt; <span class="hljs-keyword">new</span> Merge&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(i));

<span class="hljs-keyword">var</span> mergedResult = merged.RunWith(Sink.Aggregate&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">0</span>, (agg, i) =&gt; agg + i), materializer);
</code></pre>
<p>The same can be done for a <code>Sink&lt;T&gt;</code> but in this case it will be fan-out:</p>
<pre><code class="hljs lang-csharp"><span class="hljs-keyword">var</span> sendRemotely = Sink.ActorRef&lt;<span class="hljs-keyword">int</span>&gt;(actorRef, <span class="hljs-string">"Done"</span>);
<span class="hljs-keyword">var</span> localProcessing = Sink.ForEach&lt;<span class="hljs-keyword">int</span>&gt;(_ =&gt; { <span class="hljs-comment">/* do something usefull */</span> })
    .MapMaterializedValue(_=&gt; NotUsed.Instance);

<span class="hljs-keyword">var</span> sink = Sink.Combine(i =&gt; <span class="hljs-keyword">new</span> Broadcast&lt;<span class="hljs-keyword">int</span>&gt;(i), sendRemotely, localProcessing);

Source.From(<span class="hljs-keyword">new</span>[] {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>}).RunWith(sink, materializer);
</code></pre>
<h1 id="building-reusable-graph-components">Building reusable Graph components</h1>
<p>It is possible to build reusable, encapsulated components of arbitrary input and output ports using the graph DSL.</p>
<p>As an example, we will build a graph junction that represents a pool of workers, where a worker is expressed
as a <code>Flow&lt;I,O,_&gt;</code>, i.e. a simple transformation of jobs of type <code>I</code> to results of type <code>O</code> (as you have seen
already, this flow can actually contain a complex graph inside). Our reusable worker pool junction will
not preserve the order of the incoming jobs (they are assumed to have a proper ID field) and it will use a <code>Balance</code> junction to schedule jobs to available workers. On top of this, our junction will feature a &quot;fastlane&quot;, a dedicated port where jobs of higher priority can be sent.</p>
<p>Altogether, our junction will have two input ports of type <code>I</code> (for the normal and priority jobs) and an output port of type <code>O</code>. To represent this interface, we need to define a custom <code>Shape</code>. The following lines show how to do that.</p>
<pre><code class="hljs lang-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PriorityWorkerPoolShape</span>&lt;<span class="hljs-title">TIn</span>, <span class="hljs-title">TOut</span>&gt; : <span class="hljs-title">Shape</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PriorityWorkerPoolShape</span>(<span class="hljs-params">Inlet&lt;TIn&gt; jobsIn, Inlet&lt;TIn&gt; priorityJobsIn, Outlet&lt;TOut&gt; resultsOut</span>)
    </span>{
        JobsIn = jobsIn;
        PriorityJobsIn = priorityJobsIn;
        ResultsOut = resultsOut;

        Inlets = ImmutableArray.Create&lt;Inlet&gt;(jobsIn, priorityJobsIn);
        Outlets = ImmutableArray.Create&lt;Outlet&gt;(resultsOut);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> ImmutableArray&lt;Inlet&gt; Inlets { <span class="hljs-keyword">get</span>; }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> ImmutableArray&lt;Outlet&gt; Outlets { <span class="hljs-keyword">get</span>; }

    <span class="hljs-keyword">public</span> Inlet&lt;TIn&gt; JobsIn { <span class="hljs-keyword">get</span>; }

    <span class="hljs-keyword">public</span> Inlet&lt;TIn&gt; PriorityJobsIn { <span class="hljs-keyword">get</span>; }

    <span class="hljs-keyword">public</span> Outlet&lt;TOut&gt; ResultsOut { <span class="hljs-keyword">get</span>; }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Shape <span class="hljs-title">DeepCopy</span>(<span class="hljs-params"></span>)
    </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PriorityWorkerPoolShape&lt;TIn, TOut&gt;((Inlet&lt;TIn&gt;)JobsIn.CarbonCopy(),
            (Inlet&lt;TIn&gt;)PriorityJobsIn.CarbonCopy(), (Outlet&lt;TOut&gt;)ResultsOut.CarbonCopy());
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Shape <span class="hljs-title">CopyFromPorts</span>(<span class="hljs-params">ImmutableArray&lt;Inlet&gt; inlets, ImmutableArray&lt;Outlet&gt; outlets</span>)
    </span>{
        <span class="hljs-keyword">if</span> (inlets.Length != Inlets.Length)
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(
                $<span class="hljs-string">"Inlets have the wrong length, expected {Inlets.Length} found {inlets.Length}"</span>, nameof(inlets));
        <span class="hljs-keyword">if</span> (outlets.Length != Outlets.Length)
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(
                $<span class="hljs-string">"Outlets have the wrong length, expected {Outlets.Length} found {outlets.Length}"</span>, nameof(outlets));

        <span class="hljs-comment">// This is why order matters when overriding inlets and outlets.</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PriorityWorkerPoolShape&lt;TIn, TOut&gt;((Inlet&lt;TIn&gt;)inlets[<span class="hljs-number">0</span>], (Inlet&lt;TIn&gt;)inlets[<span class="hljs-number">1</span>],
            (Outlet&lt;TOut&gt;)outlets[<span class="hljs-number">0</span>]);
    }
}
</code></pre>
<h1 id="predefined-shapes">Predefined shapes</h1>
<p>In general a custom <code>Shape</code> needs to be able to provide all its input and output ports, be able to copy itself, and also be
able to create a new instance from given ports. There are some predefined shapes provided to avoid unnecessary
boilerplate:</p>
<ul>
<li><code>SourceShape</code>, <code>SinkShape</code>, <code>FlowShape</code> for simpler shapes,</li>
<li><code>UniformFanInShape</code> and <code>UniformFanOutShape</code> for junctions with multiple input (or output) ports of the same type,</li>
<li><code>FanInShape1</code>, <code>FanInShape2</code>, ..., <code>FanOutShape1</code>, <code>FanOutShape2</code>, ... for junctions with multiple input (or output) ports of different types.</li>
</ul>
<p>Since our shape has two input ports and one output port, we can just use the <code>FanInShape</code> DSL to define our custom shape:</p>
<pre><code class="hljs lang-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PriorityWorkerPoolShape2</span>&lt;<span class="hljs-title">TIn</span>, <span class="hljs-title">TOut</span>&gt; : <span class="hljs-title">FanInShape</span>&lt;<span class="hljs-title">TOut</span>&gt;
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PriorityWorkerPoolShape2</span>(<span class="hljs-params">IInit init = <span class="hljs-keyword">null</span></span>)
        : <span class="hljs-title">base</span>(<span class="hljs-params">init ?? new InitName(<span class="hljs-string">"PriorityWorkerPool"</span></span>))
    </span>{
    }

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> FanInShape&lt;TOut&gt; <span class="hljs-title">Construct</span>(<span class="hljs-params">IInit init</span>)
        </span>=&gt; <span class="hljs-keyword">new</span> PriorityWorkerPoolShape2&lt;TIn, TOut&gt;(init);

    <span class="hljs-keyword">public</span> Inlet&lt;TIn&gt; JobsIn { <span class="hljs-keyword">get</span>; } =  <span class="hljs-keyword">new</span> Inlet&lt;TIn&gt;(<span class="hljs-string">"JobsIn"</span>);

    <span class="hljs-keyword">public</span> Inlet&lt;TIn&gt; PriorityJobsIn { <span class="hljs-keyword">get</span>; } = <span class="hljs-keyword">new</span> Inlet&lt;TIn&gt;(<span class="hljs-string">"priorityJobsIn"</span>);

    <span class="hljs-comment">// Outlet[Out] with name "out" is automatically created</span>
}
</code></pre>
<p>Now that we have a <code>Shape</code> we can wire up a Graph that represents our worker pool. First, we will merge incoming normal and priority jobs using <code>MergePreferred</code>, then we will send the jobs to a <code>Balance</code> junction which will fan-out to a configurable number of workers (flows), finally we merge all these results together and send them out through our only output port. This is expressed by the following code:</p>
<pre><code class="hljs lang-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PriorityWorkerPool</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IGraph&lt;PriorityWorkerPoolShape&lt;TIn, TOut&gt;, NotUsed&gt; Create&lt;TIn, TOut&gt;(
        Flow&lt;TIn, TOut, NotUsed&gt; worker, <span class="hljs-keyword">int</span> workerCount)
    {
        <span class="hljs-keyword">return</span> GraphDsl.Create(b =&gt;
        {
            <span class="hljs-keyword">var</span> priorityMerge = b.Add(<span class="hljs-keyword">new</span> MergePreferred&lt;TIn&gt;(<span class="hljs-number">1</span>));
            <span class="hljs-keyword">var</span> balance = b.Add(<span class="hljs-keyword">new</span> Balance&lt;TIn&gt;(workerCount));
            <span class="hljs-keyword">var</span> resultsMerge = b.Add(<span class="hljs-keyword">new</span> Merge&lt;TOut&gt;(workerCount));

            <span class="hljs-comment">// After merging priority and ordinary jobs, we feed them to the balancer</span>
            b.From(priorityMerge).To(balance);

            <span class="hljs-comment">// Wire up each of the outputs of the balancer to a worker flow</span>
            <span class="hljs-comment">// then merge them back</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; workerCount; i++)
                b.From(balance.Out(i)).Via(worker).To(resultsMerge.In(i));

            <span class="hljs-comment">// We now expose the input ports of the priorityMerge and the output</span>
            <span class="hljs-comment">// of the resultsMerge as our PriorityWorkerPool ports</span>
            <span class="hljs-comment">// -- all neatly wrapped in our domain specific Shape</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PriorityWorkerPoolShape&lt;TIn, TOut&gt;(jobsIn: priorityMerge.In(<span class="hljs-number">0</span>),
                priorityJobsIn: priorityMerge.Preferred, resultsOut: resultsMerge.Out);
        });
    }
}
</code></pre>
<p>All we need to do now is to use our custom junction in a graph. The following code simulates some simple workers
and jobs using plain strings and prints out the results. Actually we used <em>two</em> instances of our worker pool junction
using <code>Add()</code> twice.</p>
<pre><code class="hljs lang-csharp"><span class="hljs-keyword">var</span> worker1 = Flow.Create&lt;<span class="hljs-keyword">string</span>&gt;().Select(s =&gt; <span class="hljs-string">"step 1 "</span> + s);
<span class="hljs-keyword">var</span> worker2 = Flow.Create&lt;<span class="hljs-keyword">string</span>&gt;().Select(s =&gt; <span class="hljs-string">"step 2 "</span> + s);

RunnableGraph.FromGraph(GraphDsl.Create(b =&gt;
{
    Func&lt;<span class="hljs-keyword">string</span>, Source&lt;<span class="hljs-keyword">string</span>, NotUsed&gt;&gt; createSource = desc =&gt;
        Source.From(Enumerable.Range(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>))
            .Select(s =&gt; desc + s);

    <span class="hljs-keyword">var</span> priorityPool1 = b.Add(PriorityWorkerPool.Create(worker1, <span class="hljs-number">4</span>));
    <span class="hljs-keyword">var</span> priorityPool2 = b.Add(PriorityWorkerPool.Create(worker2, <span class="hljs-number">2</span>));

    b.From(createSource(<span class="hljs-string">"job: "</span>)).To(priorityPool1.JobsIn);
    b.From(createSource(<span class="hljs-string">"priority job: "</span>)).To(priorityPool1.PriorityJobsIn);

    b.From(priorityPool1.ResultsOut).To(priorityPool2.JobsIn);
    b.From(createSource(<span class="hljs-string">"one-step, priority : "</span>)).To(priorityPool2.PriorityJobsIn);

    <span class="hljs-keyword">var</span> sink = Sink.ForEach&lt;<span class="hljs-keyword">string</span>&gt;(Console.WriteLine).MapMaterializedValue(_ =&gt; NotUsed.Instance);
    b.From(priorityPool2.ResultsOut).To(sink);
    <span class="hljs-keyword">return</span> ClosedShape.Instance;
})).Run(materializer);
</code></pre>
<h1 id="bidirectional-flows">Bidirectional Flows</h1>
<p>A graph topology that is often useful is that of two flows going in opposite directions. Take for example a codec stage that serializes outgoing messages and deserializes incoming octet streams. Another such stage could add a framing protocol that attaches a length header to outgoing data and parses incoming frames back into the original octet stream chunks. These two stages are meant to be composed, applying one atop the other as part of a protocol stack. For this purpose exists the special type <code>BidiFlow</code> which is a graph that has exactly two open inlets and two open outlets. The corresponding shape is called <code>BidiShape</code> and is defined like this:</p>
<pre><code class="hljs lang-csharp"><span class="hljs-comment">/**
 * A bidirectional flow of elements that consequently has two inputs and two
 * outputs, arranged like this:
 *
 * 
 *        +------+
 *  In1 ~&gt;|      |~&gt; Out1
 *        | bidi |
 * Out2 &lt;~|      |&lt;~ In2
 *        +------+
 * 
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BidiShape</span>&lt;<span class="hljs-title">TIn1</span>, <span class="hljs-title">TOut1</span>, <span class="hljs-title">TIn2</span>, <span class="hljs-title">TOut2</span>&gt; : <span class="hljs-title">Shape</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BidiShape</span>(<span class="hljs-params">Inlet&lt;TIn1&gt; in1, Outlet&lt;TOut1&gt; out1, Inlet&lt;TIn2&gt; in2, Outlet&lt;TOut2&gt; out2</span>)
    </span>{
    }

    <span class="hljs-comment">// implementation details elided ...</span>
}
</code></pre>
<p>A bidirectional flow is defined just like a unidirectional <code>Flow</code> as demonstrated for the codec mentioned above:</p>
<pre><code class="hljs lang-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IMessage</span> { }

<span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> Ping : IMessage
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Ping</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> id</span>)
    </span>{
        Id = id;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Id { <span class="hljs-keyword">get</span>; }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> Pong : IMessage
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pong</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> id</span>)
    </span>{
        Id = id;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Id { <span class="hljs-keyword">get</span>; }
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteString <span class="hljs-title">ToBytes</span>(<span class="hljs-params">IMessage message</span>)
</span>{
    <span class="hljs-comment">// implementation details elided ...</span>
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IMessage <span class="hljs-title">FromBytes</span>(<span class="hljs-params">ByteString bytes</span>)
</span>{
    <span class="hljs-comment">// implementation details elided ...</span>
}

<span class="hljs-keyword">var</span> codecVerbose =
  BidiFlow.FromGraph(GraphDsl.Create(b =&gt;
  {
      <span class="hljs-comment">// construct and add the top flow, going outbound</span>
      <span class="hljs-keyword">var</span> outbound = b.Add(Flow.Create&lt;IMessage&gt;().Select(ToBytes));
      <span class="hljs-comment">// construct and add the bottom flow, going inbound</span>
      <span class="hljs-keyword">var</span> inbound = b.Add(Flow.Create&lt;ByteString&gt;().Select(FromBytes));
      <span class="hljs-comment">// fuse them together into a BidiShape</span>
      <span class="hljs-keyword">return</span> BidiShape.FromFlows(outbound, inbound);
  }));

<span class="hljs-comment">// this is the same as the above</span>
<span class="hljs-keyword">var</span> codec = BidiFlow.FromFunction&lt;IMessage, ByteString, ByteString, IMessage&gt;(ToBytes, FromBytes);
</code></pre>
<p>The first version resembles the partial graph constructor, while for the simple case of a functional 1:1 transformation there is a concise convenience method as shown on the last line. The implementation of the two functions is not difficult either:</p>
<pre><code class="hljs lang-csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteString <span class="hljs-title">ToBytes</span>(<span class="hljs-params">IMessage message</span>)
</span>{
    <span class="hljs-keyword">var</span> order = ByteOrder.LittleEndian;

    <span class="hljs-keyword">var</span> ping = message <span class="hljs-keyword">as</span> Ping;
    <span class="hljs-keyword">if</span> (ping != <span class="hljs-keyword">null</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ByteStringBuilder().PutByte(<span class="hljs-number">1</span>).PutInt(ping.Id, order).Result();

    <span class="hljs-keyword">var</span> pong = message <span class="hljs-keyword">as</span> Pong;
    <span class="hljs-keyword">if</span> (pong != <span class="hljs-keyword">null</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ByteStringBuilder().PutByte(<span class="hljs-number">2</span>).PutInt(pong.Id, order).Result();

    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(<span class="hljs-string">"Message is neither Pong nor Ping"</span>, nameof(message));
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IMessage <span class="hljs-title">FromBytes</span>(<span class="hljs-params">ByteString bytes</span>)
</span>{
    <span class="hljs-keyword">var</span> order = ByteOrder.LittleEndian;
    <span class="hljs-keyword">var</span> it = bytes.Iterator();
    <span class="hljs-keyword">var</span> b = it.GetByte();

    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Ping(it.GetInt(order));
    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">2</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pong(it.GetInt(order));

    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SystemException($<span class="hljs-string">"Parse error: expected 1|2 got {b}"</span>);
}
</code></pre>
<p>In this way you could easily integrate any other serialization library that turns an object into a sequence of bytes.</p>
<p>The other stage that we talked about is a little more involved since reversing a framing protocol means that any received chunk of bytes may correspond to zero or more messages. This is best implemented using a <code>GraphStage</code> (see also <a href="customstreamprocessing#custom-processing-with-graphstage">Custom processing with GraphStage</a>).</p>
<pre><code class="hljs lang-csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteString <span class="hljs-title">AddLengthHeader</span>(<span class="hljs-params">ByteString bytes, ByteOrder order</span>)
    </span>=&gt; <span class="hljs-keyword">new</span> ByteStringBuilder().PutInt(bytes.Count, order).Append(bytes).Result();

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FrameParser</span> : <span class="hljs-title">GraphStage</span>&lt;<span class="hljs-title">FlowShape</span>&lt;<span class="hljs-title">ByteString</span>, <span class="hljs-title">ByteString</span>&gt;&gt;
{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Logic</span> : <span class="hljs-title">GraphStageLogic</span>
    {
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> FrameParser _parser;
        <span class="hljs-comment">// this holds the received but not yet parsed bytes</span>
        <span class="hljs-keyword">private</span> ByteString _stash;
        <span class="hljs-comment">// this holds the current message length or -1 if at a boundary</span>
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> _needed = -<span class="hljs-number">1</span>;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Logic</span>(<span class="hljs-params">FrameParser parser</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">parser.Shape</span>)
        </span>{
            _parser = parser;
            _stash = ByteString.Empty;

            SetHandler(parser.Out, onPull: () =&gt;
            {
                <span class="hljs-keyword">if</span> (IsClosed(parser.In))
                    Run();
                <span class="hljs-function"><span class="hljs-keyword">else</span>
                    <span class="hljs-title">Pull</span>(<span class="hljs-params">parser.In</span>)</span>;
            });

            SetHandler(parser.In, onPush: () =&gt;
            {
                <span class="hljs-keyword">var</span> bytes = Grab(parser.In);
                _stash += bytes;
                Run();
            }, onUpstreamFinish: () =&gt;
            {
                <span class="hljs-keyword">if</span>(_stash.IsEmpty)
                    CompleteStage();
                <span class="hljs-comment">// wait with completion and let Run() complete when the</span>
                <span class="hljs-comment">// rest of the stash has been sent downstream</span>
            });
        }

        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Run</span>(<span class="hljs-params"></span>)
        </span>{
            <span class="hljs-keyword">if</span> (_needed == -<span class="hljs-number">1</span>)
            { 
                <span class="hljs-comment">// are we at a boundary? then figure out next length</span>
                <span class="hljs-keyword">if</span> (_stash.Count &lt; <span class="hljs-number">4</span>)
                {
                    <span class="hljs-keyword">if</span> (IsClosed(_parser.In))
                        CompleteStage();
                    <span class="hljs-function"><span class="hljs-keyword">else</span>
                        <span class="hljs-title">Pull</span>(<span class="hljs-params">_parser.In</span>)</span>;
                }
                <span class="hljs-keyword">else</span>
                {
                    _needed = _stash.Iterator().GetInt(_parser._order);
                    _stash = _stash.Drop(<span class="hljs-number">4</span>);
                    Run(); <span class="hljs-comment">// cycle back to possibly already emit the next chunk</span>
                }
            }
            <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> (<span class="hljs-params">_stash.Count &lt; _needed</span>)
            </span>{
                <span class="hljs-comment">// we are in the middle of a message, need more bytes,</span>
                <span class="hljs-comment">// or have to stop if input closed</span>
                <span class="hljs-keyword">if</span> (IsClosed(_parser.In))
                    CompleteStage();
                <span class="hljs-function"><span class="hljs-keyword">else</span>
                    <span class="hljs-title">Pull</span>(<span class="hljs-params">_parser.In</span>)</span>;
            }
            <span class="hljs-keyword">else</span>
            {
                <span class="hljs-comment">// we have enough to emit at least one message, so do it</span>
                <span class="hljs-keyword">var</span> emit = _stash.Take(_needed);
                _stash = _stash.Drop(_needed);
                _needed = -<span class="hljs-number">1</span>;
                Push(_parser.Out, emit);
            }
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ByteOrder _order;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FrameParser</span>(<span class="hljs-params">ByteOrder order</span>)
    </span>{
        _order = order;
        Shape = <span class="hljs-keyword">new</span> FlowShape&lt;ByteString, ByteString&gt;(In, Out);
    }

    <span class="hljs-keyword">public</span> Inlet&lt;ByteString&gt; In { <span class="hljs-keyword">get</span>; } = <span class="hljs-keyword">new</span> Inlet&lt;ByteString&gt;(<span class="hljs-string">"FrameParser.in"</span>);

    <span class="hljs-keyword">public</span> Outlet&lt;ByteString&gt; Out { <span class="hljs-keyword">get</span>; } = <span class="hljs-keyword">new</span> Outlet&lt;ByteString&gt;(<span class="hljs-string">"FrameParser.out"</span>);

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> FlowShape&lt;ByteString, ByteString&gt; Shape { <span class="hljs-keyword">get</span>; }

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> GraphStageLogic <span class="hljs-title">CreateLogic</span>(<span class="hljs-params">Attributes inheritedAttributes</span>) </span>=&gt; <span class="hljs-keyword">new</span> Logic(<span class="hljs-keyword">this</span>);
}

<span class="hljs-keyword">var</span> framing =
    BidiFlow.FromGraph(
        GraphDsl.Create(b =&gt;
        {
            <span class="hljs-keyword">var</span> order = ByteOrder.LittleEndian;

            <span class="hljs-keyword">var</span> outbound = b.Add(Flow.Create&lt;ByteString&gt;().Select(bytes =&gt; AddLengthHeader(bytes, order)));
            <span class="hljs-keyword">var</span> inbound = b.Add(Flow.Create&lt;ByteString&gt;().Via(<span class="hljs-keyword">new</span> FrameParser(order)));

            <span class="hljs-keyword">return</span> BidiShape.FromFlows(outbound, inbound);
        }));
</code></pre>
<p>With these implementations we can build a protocol stack and test it:</p>
<pre><code class="hljs lang-csharp"><span class="hljs-comment">/* construct protocol stack
 *         +------------------------------------+
 *         | stack                              |
 *         |                                    |
 *         |  +-------+            +---------+  |
 *    ~&gt;   O~~o       |     ~&gt;     |         o~~O    ~&gt;
 * Message |  | codec | ByteString | framing |  | ByteString
 *    &lt;~   O~~o       |     &lt;~     |         o~~O    &lt;~
 *         |  +-------+            +---------+  |
 *         +------------------------------------+
 */</span>

<span class="hljs-keyword">var</span> stack = codec.Atop(framing);

<span class="hljs-comment">// test it by plugging it into its own inverse and closing the right end</span>
<span class="hljs-keyword">var</span> pingpong = Flow.Create&lt;IMessage&gt;().Collect(message =&gt;
{
    <span class="hljs-keyword">var</span> ping = message <span class="hljs-keyword">as</span> Ping;
    <span class="hljs-keyword">return</span> ping != <span class="hljs-keyword">null</span>
        ? <span class="hljs-keyword">new</span> Pong(ping.Id) <span class="hljs-keyword">as</span> IMessage
        : <span class="hljs-keyword">null</span>;
});
<span class="hljs-keyword">var</span> flow = stack.Atop(stack.Reversed()).Join(pingpong);
<span class="hljs-keyword">var</span> result =
    Source.From(Enumerable.Range(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>))
        .Select(i =&gt; <span class="hljs-keyword">new</span> Ping(i) <span class="hljs-keyword">as</span> IMessage)
        .Via(flow)
        .Limit(<span class="hljs-number">20</span>)
        .RunWith(Sink.Seq&lt;IMessage&gt;(), materializer);

result.Wait(TimeSpan.FromSeconds(<span class="hljs-number">1</span>)).Should().BeTrue();
result.Result.ShouldAllBeEquivalentTo(Enumerable.Range(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>));
</code></pre>
<p>This example demonstrates how <code>BidiFlow</code> subgraphs can be hooked together and also turned around with the <code>.Reversed</code> method. The test simulates both parties of a network communication protocol without actually having to open a network connection—the flows can just be connected directly.</p>
<h1 id="accessing-the-materialized-value-inside-the-graph">Accessing the materialized value inside the Graph</h1>
<p>In certain cases it might be necessary to feed back the materialized value of a Graph (partial, closed or backing a
Source, Sink, Flow or BidiFlow). This is possible by using <code>builder.MaterializedValue</code> which gives an <code>Outlet</code> that
can be used in the graph as an ordinary source or outlet, and which will eventually emit the materialized value.
If the materialized value is needed at more than one place, it is possible to call <code>MaterializedValue</code> any number of
times to acquire the necessary number of outlets.</p>
<pre><code class="hljs lang-csharp"><span class="hljs-keyword">var</span> aggregateFlow = Flow.FromGraph(GraphDsl.Create(Sink.Aggregate&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">0</span>, (sum, i) =&gt; sum + i), (b, aggregate) =&gt;
{
    <span class="hljs-keyword">var</span> outlet = b.From(b.MaterializedValue)
        .Via(Flow.Create&lt;Task&lt;<span class="hljs-keyword">int</span>&gt;&gt;().SelectAsync(<span class="hljs-number">4</span>, x =&gt; x))
        .Out;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FlowShape&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(aggregate.Inlet, outlet);
}));
</code></pre>
<p>Be careful not to introduce a cycle where the materialized value actually contributes to the materialized value.
The following example demonstrates a case where the materialized <code>Task</code> of a aggregate is fed back to the aggregate itself.</p>
<pre><code class="hljs lang-csharp"><span class="hljs-keyword">var</span> cyclicAggregate = Source.FromGraph(GraphDsl.Create(Sink.Aggregate&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">0</span>, (sum, i) =&gt; sum + i),
    (b, aggregate) =&gt;
    {
        <span class="hljs-comment">// - Aggregate cannot complete until its upstream SelectAsync completes</span>
        <span class="hljs-comment">// - SelectAsync cannot complete until the materialized Task produced by</span>
        <span class="hljs-comment">//   Aggregate completes</span>
        <span class="hljs-comment">// As a result this Source will never emit anything, and its materialized</span>
        <span class="hljs-comment">// Task will never complete</span>
        <span class="hljs-keyword">var</span> flow = Flow.Create&lt;Task&lt;<span class="hljs-keyword">int</span>&gt;&gt;().SelectAsync(<span class="hljs-number">4</span>, x =&gt; x);
        b.From(b.MaterializedValue).Via(flow).To(aggregate);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SourceShape&lt;<span class="hljs-keyword">int</span>&gt;(b.From(b.MaterializedValue).Via(flow).Out);
    }));
</code></pre>
<h1 id="graph-cycles-liveness-and-deadlocks">Graph cycles, liveness and deadlocks</h1>
<p>Cycles in bounded stream topologies need special considerations to avoid potential deadlocks and other liveness issues. This section shows several examples of problems that can arise from the presence of feedback arcs in stream processing graphs.</p>
<p>The first example demonstrates a graph that contains a naïve cycle. The graph takes elements from the source, prints them, then broadcasts those elements to a consumer (we just used <code>Sink.Ignore</code> for now) and to a feedback arc that is merged back into the main stream via a <code>Merge</code> junction.</p>
<div class="alert alert-default">
<p><strong>Note</strong><br/>
The graph DSL allows the connection methods to be reversed, which is particularly handy when writing cycles—as we will see there are cases where this is very helpful.</p>
</div>
<pre><code class="hljs lang-csharp"><span class="hljs-comment">// WARNING! The graph below deadlocks!</span>
RunnableGraph.FromGraph(GraphDsl.Create(b =&gt;
{
    <span class="hljs-keyword">var</span> merge = b.Add(<span class="hljs-keyword">new</span> Merge&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));
    <span class="hljs-keyword">var</span> broadcast = b.Add(<span class="hljs-keyword">new</span> Broadcast&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));
    <span class="hljs-keyword">var</span> print = Flow.Create&lt;<span class="hljs-keyword">int</span>&gt;().Select(s =&gt;
    {
        Console.WriteLine(s);
        <span class="hljs-keyword">return</span> s;
    });

    <span class="hljs-keyword">var</span> sink = Sink.Ignore&lt;<span class="hljs-keyword">int</span>&gt;().MapMaterializedValue(_ =&gt; NotUsed.Instance);
    b.From(source).Via(merge).Via(print).Via(broadcast).To(sink);
    b.To(merge).From(broadcast);

    <span class="hljs-keyword">return</span> ClosedShape.Instance;
}));
</code></pre>
<p>Running this we observe that after a few numbers have been printed, no more elements are logged to the console -
all processing stops after some time. After some investigation we observe that:</p>
<ul>
<li>through merging from <code>source</code> we increase the number of elements flowing in the cycle</li>
<li>by broadcasting back to the cycle we do not decrease the number of elements in the cycle</li>
</ul>
<p>Since Akka Streams (and Reactive Streams in general) guarantee bounded processing (see the &quot;Buffering&quot; section for more
details) it means that only a bounded number of elements are buffered over any time span. Since our cycle gains more and
more elements, eventually all of its internal buffers become full, backpressuring <code>source</code> forever. To be able
to process more elements from <code>source</code> elements would need to leave the cycle somehow.</p>
<p>If we modify our feedback loop by replacing the <code>Merge</code> junction with a <code>MergePreferred</code> we can avoid the deadlock.
<code>MergePreferred</code> is unfair as it always tries to consume from a preferred input port if there are elements available
before trying the other lower priority input ports. Since we feed back through the preferred port it is always guaranteed
that the elements in the cycles can flow.</p>
<pre><code class="hljs lang-csharp"><span class="hljs-comment">// WARNING! The graph below stops consuming from "source" after a few steps</span>
RunnableGraph.FromGraph(GraphDsl.Create(b =&gt;
{
    <span class="hljs-keyword">var</span> merge = b.Add(<span class="hljs-keyword">new</span> MergePreferred&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">1</span>));
    <span class="hljs-keyword">var</span> broadcast = b.Add(<span class="hljs-keyword">new</span> Broadcast&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));
    <span class="hljs-keyword">var</span> print = Flow.Create&lt;<span class="hljs-keyword">int</span>&gt;().Select(s =&gt;
    {
        Console.WriteLine(s);
        <span class="hljs-keyword">return</span> s;
    });

    <span class="hljs-keyword">var</span> sink = Sink.Ignore&lt;<span class="hljs-keyword">int</span>&gt;().MapMaterializedValue(_ =&gt; NotUsed.Instance);
    b.From(source).Via(merge).Via(print).Via(broadcast).To(sink);
    b.To(merge.Preferred).From(broadcast);

    <span class="hljs-keyword">return</span> ClosedShape.Instance;
}));
</code></pre>
<p>If we run the example we see that the same sequence of numbers are printed over and over again, but the processing does not stop. Hence, we avoided the deadlock, but <code>source</code> is still back-pressured forever, because buffer space is never recovered: the only action we see is the circulation of a couple of initial elements from <code>source</code>.</p>
<div class="alert alert-default">
<p><strong>Note</strong><br/>
What we see here is that in certain cases we need to choose between boundedness and liveness. Our first example would not deadlock if there would be an infinite buffer in the loop, or vice versa, if the elements in the cycle would be balanced (as many elements are removed as many are injected) then there would be no deadlock.</p>
</div>
<p>To make our cycle both live (not deadlocking) and fair we can introduce a dropping element on the feedback arc. In this
case we chose the <code>Buffer()</code> operation giving it a dropping strategy <code>OverflowStrategy.DropHead</code>.</p>
<pre><code class="hljs lang-csharp">RunnableGraph.FromGraph(GraphDsl.Create(b =&gt;
{
    <span class="hljs-keyword">var</span> merge = b.Add(<span class="hljs-keyword">new</span> Merge&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));
    <span class="hljs-keyword">var</span> broadcast = b.Add(<span class="hljs-keyword">new</span> Broadcast&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));
    <span class="hljs-keyword">var</span> print = Flow.Create&lt;<span class="hljs-keyword">int</span>&gt;().Select(s =&gt;
    {
        Console.WriteLine(s);
        <span class="hljs-keyword">return</span> s;
    });
    <span class="hljs-keyword">var</span> buffer = Flow.Create&lt;<span class="hljs-keyword">int</span>&gt;().Buffer(<span class="hljs-number">10</span>, OverflowStrategy.DropHead);

    <span class="hljs-keyword">var</span> sink = Sink.Ignore&lt;<span class="hljs-keyword">int</span>&gt;().MapMaterializedValue(_ =&gt; NotUsed.Instance);
    b.From(source).Via(merge).Via(print).Via(broadcast).To(sink);
    b.To(merge).Via(buffer).From(broadcast);

    <span class="hljs-keyword">return</span> ClosedShape.Instance;
}));
</code></pre>
<p>If we run this example we see that</p>
<ul>
<li>The flow of elements does not stop, there are always elements printed</li>
<li>We see that some of the numbers are printed several times over time (due to the feedback loop) but on average
the numbers are increasing in the long term</li>
</ul>
<p>This example highlights that one solution to avoid deadlocks in the presence of potentially unbalanced cycles
(cycles where the number of circulating elements are unbounded) is to drop elements. An alternative would be to
define a larger buffer with <code>OverflowStrategy.Fail</code> which would fail the stream instead of deadlocking it after
all buffer space has been consumed.</p>
<p>As we discovered in the previous examples, the core problem was the unbalanced nature of the feedback loop. We
circumvented this issue by adding a dropping element, but now we want to build a cycle that is balanced from
the beginning instead. To achieve this we modify our first graph by replacing the <code>Merge</code> junction with a <code>ZipWith</code>.
Since <code>ZipWith</code> takes one element from <code>source</code> <em>and</em> from the feedback arc to inject one element into the cycle,
we maintain the balance of elements.</p>
<pre><code class="hljs lang-csharp"><span class="hljs-comment">// WARNING! The graph below never processes any elements</span>
RunnableGraph.FromGraph(GraphDsl.Create(b =&gt;
{
    <span class="hljs-keyword">var</span> zip = b.Add(ZipWith.Apply&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(Keep.Right));
    <span class="hljs-keyword">var</span> broadcast = b.Add(<span class="hljs-keyword">new</span> Broadcast&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));
    <span class="hljs-keyword">var</span> print = Flow.Create&lt;<span class="hljs-keyword">int</span>&gt;().Select(s =&gt;
    {
        Console.WriteLine(s);
        <span class="hljs-keyword">return</span> s;
    });

    <span class="hljs-keyword">var</span> sink = Sink.Ignore&lt;<span class="hljs-keyword">int</span>&gt;().MapMaterializedValue(_ =&gt; NotUsed.Instance);

    b.From(source).To(zip.In0);
    b.From(zip.Out).Via(print).Via(broadcast).To(sink);
    b.To(zip.In1).From(broadcast);

    <span class="hljs-keyword">return</span> ClosedShape.Instance;
}));
</code></pre>
<p>Still, when we try to run the example it turns out that no element is printed at all! After some investigation we
realize that:</p>
<ul>
<li>In order to get the first element from <code>source</code> into the cycle we need an already existing element in the cycle</li>
<li>In order to get an initial element in the cycle we need an element from <code>source</code></li>
</ul>
<p>These two conditions are a typical &quot;chicken-and-egg&quot; problem. The solution is to inject an initial
element into the cycle that is independent from <code>source</code>. We do this by using a <code>Concat</code> junction on the backwards
arc that injects a single element using <code>Source.Single</code>.</p>
<div class="alert alert-warning">
<p><strong>Warning</strong><br/>
This approach isn&#39;t working in the current beta, the graph is still not printing any elements.</p>
</div>
<pre><code class="hljs lang-csharp">RunnableGraph.FromGraph(GraphDsl.Create(b =&gt;
{
    <span class="hljs-keyword">var</span> zip = b.Add(ZipWith.Apply&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(Keep.Right));
    <span class="hljs-keyword">var</span> broadcast = b.Add(<span class="hljs-keyword">new</span> Broadcast&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));
    <span class="hljs-keyword">var</span> concat = b.Add(<span class="hljs-keyword">new</span> Concat&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;());
    <span class="hljs-keyword">var</span> start = Source.Single(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">var</span> print = Flow.Create&lt;<span class="hljs-keyword">int</span>&gt;().Select(s =&gt;
    {
        Console.WriteLine(s);
        <span class="hljs-keyword">return</span> s;
    });
    <span class="hljs-keyword">var</span> sink = Sink.Ignore&lt;<span class="hljs-keyword">int</span>&gt;().MapMaterializedValue(_ =&gt; NotUsed.Instance);

    b.From(source).To(zip.In0);
    b.From(zip.Out).Via(print).Via(broadcast).To(sink);

    b.To(zip.In1).Via(concat).From(start);
                 b.To(concat).From(broadcast);

    <span class="hljs-keyword">return</span> ClosedShape.Instance;
}));
</code></pre>
<p>When we run the above example we see that processing starts and never stops. The important takeaway from this example is that balanced cycles often need an initial &quot;kick-off&quot; element to be injected into the cycle.</p>
</div>

								

						</div>
						<div class="col-md-1">&nbsp;</div>
						<!-- /LEFT COLUMNS -->



					</div>

				</div>
			</section>
			<!-- /CONTENT -->

			<footer id="footer">
  <div class="container">
    <div class="row">
        <!-- col #1 -->
        <div class="spaced dark col-md-3">
            <h4>About <strong>Akka.NET</strong></h4>
            <p class="block">
                Akka.NET is a port of the popular
                <br/> Java/Scala framework <a href="http://akka.io">Akka</a> to .NET.
                <br/>
                <br/> This is a community driven port and
                <br/> is not affiliated with <a href="http://typesafe.com">Typesafe</a> who
                <br/> makes the original Java/Scala version.
                <br/>
            </p>
            <!-- social -->
            <p class="block">
                <a href="mailto:hi@getakka.net">hi@getakka.net</a><br>
                <a href="https://www.facebook.com/akkadotnet" class="social fa fa-facebook"></a>
                <a href="http://stackoverflow.com/questions/tagged/akka.net" class="social fa fa-stack-overflow"></a>
                <a href="https://twitter.com/AkkaDotNET" class="social fa fa-twitter"></a>
            </p><!-- /social -->
        </div>
        <!-- /col #1 -->
        <!-- col #3 -->
        <div class="spaced col-md-6 col-sm-4">
            <h4>Recent <strong>Tweets</strong></h4>
            <ul class="list-unstyled fsize13" id="recent_tweets">
            </ul>
        </div>
        <!-- /col #3 -->
        <div class="spaced col-md-3 col-sm-4">
            <h4>Keep <strong>Updated</strong></h4>
            <h4><small><strong>Subscribe to our Newsletter</strong></small></h4>
            <!-- Begin MailChimp Signup Form -->
<div id="mc_embed_signup">
    <form class="input-group" action="//github.us8.list-manage.com/subscribe/post?u=945d2a2edaa89aaabd396bc45&amp;id=5f9a7a993d" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
        <input type="email" value="" name="EMAIL" class="form-control placeholder required email" id="mce-EMAIL" placeholder="E-mail Address">
        <span class="input-group-btn">
  <button class="btn btn-primary" type="submit" name="subscribe" id="mc-embedded-subscribe">SUBMIT</button>
</span>
        <div id="mce-responses" class="clear">
            <div class="response" id="mce-error-response" style="display:none"></div>
            <div class="response" id="mce-success-response" style="display:none"></div>
        </div>
        <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
        <div style="position: absolute; left: -5000px;">
            <input type="text" name="b_945d2a2edaa89aaabd396bc45_5f9a7a993d" tabindex="-1" value="">
        </div>
        <div class="clear"></div>
    </form>
</div>
<!--End mc_embed_signup-->

        </div>
    </div>
  </div>
  <hr />
  <!-- <div class="copyright">
    <div class="container text-center fsize12"></div>
  </div> -->
</footer>


			<a href="#" id="toTop"></a>

		</div><!-- /#wrapper -->

		<script type="text/javascript" src="/theme_assets/plugins/jquery-2.1.1.min.js"></script>
<script type="text/javascript" src="/theme_assets/plugins/jquery.isotope.js"></script>
<script type="text/javascript" src="/theme_assets/plugins/masonry.js"></script>
<script type="text/javascript" src="/theme_assets/plugins/bootstrap/js/bootstrap.min.js"></script>
<script type="text/javascript" src="/theme_assets/plugins/magnific-popup/jquery.magnific-popup.min.js"></script>
<script type="text/javascript" src="/theme_assets/plugins/owl-carousel/owl.carousel.min.js"></script>
<script type="text/javascript" src="/theme_assets/plugins/knob/js/jquery.knob.js"></script>
<script type="text/javascript" src="/theme_assets/plugins/flexslider/jquery.flexslider-min.js"></script>

<!-- REVOLUTION SLIDER -->
<script type="text/javascript" src="/theme_assets/plugins/revolution-slider/js/jquery.themepunch.plugins.min.js"></script>
<script type="text/javascript" src="/theme_assets/plugins/revolution-slider/js/jquery.themepunch.revolution.min.js"></script>
<script type="text/javascript" src="/theme_assets/js/revolution_slider.js"></script>
<script type="text/javascript" src="/js/jquery-toc.js"></script>
<script type="text/javascript" src="/theme_assets/js/scripts.js"></script>
<script type="text/javascript" src="/js/scripts.js"></script>
		<!-- REACTIVE MANIFESTO BANNER -->
<a href="http://www.reactivemanifesto.org/"> <img style="border: 0; position: fixed; right: 0; top:0; z-index: 9000; max-width: 125px;" src="//d379ifj7s9wntv.cloudfront.net/reactivemanifesto/images/ribbons/we-are-reactive-red-right.png"> </a>

	</body>
</html>
