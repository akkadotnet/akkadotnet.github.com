<!DOCTYPE html>
<!--[if IE 8]>			<html class="ie ie8"> <![endif]-->
<!--[if IE 9]>			<html class="ie ie9"> <![endif]-->
<!--[if gt IE 9]><!-->	<html> <!--<![endif]-->
	<head>
		

<meta charset="utf-8" />
<title>Modularity, Composition and Hierarchy | Akka.NET</title>

<meta name="keywords" content="Actor,Finite state machine, concurrency" />
<meta name="description" content="" />
<meta name="Author" content="Dorin Grigoras [www.stepofweb.com]" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />

<!-- mobile settings -->
<meta name="viewport" contenht="width=device-width, maximum-scale=1, initial-scale=1, user-scalable=0" />

<!-- Favicon -->
<link rel="shortcut icon" href="/theme_assets/images/demo/favicon.ico" />

<!-- WEB FONTS -->
<link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,700,800&amp;subset=latin,latin-ext" rel="stylesheet" type="text/css" />

<!-- CORE CSS -->
<link href="/theme_assets/plugins/bootstrap/css/bootstrap.min.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/font-awesome.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/sky-forms.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/weather-icons.min.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/line-icons.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/plugins/owl-carousel/owl.pack.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/plugins/magnific-popup/magnific-popup.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/animate.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/flexslider.css" rel="stylesheet" type="text/css" />

<!-- FAV ICON -->
<link rel="shortcut icon" href="http://akkadotnet.github.io/favicon.ico?v=2" />

<!-- REVOLUTION SLIDER -->
<link href="/theme_assets/css/revolution-slider.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/layerslider.css" rel="stylesheet" type="text/css" />

<!-- BLOG -->
<link href="/theme_assets/css/layout-blog.css" rel="stylesheet" type="text/css" />

<!-- THEME CSS -->
<link href="/theme_assets/css/essentials.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/layout.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/header-default.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/footer-default.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/color_scheme/red.css" rel="stylesheet" type="text/css" id="color_scheme" />

<!-- Highlighting -->
<link href="https://highlightjs.org/static/demo/styles/github.css" rel="stylesheet" type="text/css" />
<link href="/css/screen.css" rel="stylesheet" type="text/css" />

<!-- Modernizr -->
<script type="text/javascript" src="/theme_assets/plugins/modernizr.min.js"></script>

<!--[if lte IE 8]>
  <script src="/theme_assets/plugins/respond.js"></script>
<![endif]-->

	</head>

	<!--
		Available body classes:
			smoothscroll			= enable chrome browser smooth scroll
			grey 					= grey content background
			boxed 					= boxed style
			pattern1 ... pattern10 	= background pattern

		Background Image - add to body:
			data-background="/theme_assets/images/boxed_background/1.jpg"
	-->
	<body class=" ">

		<div id="wrapper">
			<div id="header">
  <header id="topBar">
    <div class="container">

      

      <!-- Logo -->
      <a class="logo" href="/">
        <img src="/images/akkalogo.png"  alt="" style="padding-top:0px;padding-left: 5px;" />
      </a>

    </div><!-- /.container -->
  </header>
  <div id="topNav">
  <div class="container">
    <!-- Mobile Menu Button -->
    <button class="btn btn-mobile" data-toggle="collapse" data-target=".nav-main-collapse">
      <i class="fa fa-bars"></i>
    </button>

    <!-- Search -->
    <form class="search" method="get" action="/search">
      <input type="text" class="form-control" name="q" value="" placeholder="Search">
      <button class="fa fa-search"></button>
    </form>
    <!-- /Search -->

    <!-- Top Nav -->
    <div class="navbar-collapse nav-main-collapse collapse inline-block">
      <nav class="nav-main">

      

        <!-- pageurl  -->
        <ul id="topMain" class="nav nav-pills nav-main">
          <li class="mega-menu  active">
            <a href="/docs/">DOCUMENTATION<span>&nbsp;</span></a>
          </li>
          <li class="mega-menu">
            <a href="https://github.com/akkadotnet/akka.net/">CODE<span>&nbsp;</span></a>
          </li>
          <li class="mega-menu">
            <a href="https://gitter.im/akkadotnet/akka.net">PROJECT CHAT<span>&nbsp;</span></a>
          </li>
          <li class="mega-menu">
            <a href="https://groups.google.com/forum/#!forum/akkadotnet-user-list">MAILING LIST<span>&nbsp;</span></a>
          </li>
          <li class="mega-menu ">
            <a href="/pages/support">COMMERCIAL SUPPORT<span>&nbsp;</span></a>
          </li>
          <li class="mega-menu ">
            <a href="/docs/Resources">RESOURCES<span>&nbsp;</span></a>
          </li>
        </ul>

      </nav>
    </div>
</div>
</div>
			

			<!-- PAGE TOP -->
			<section class="page-title">
				<div class="container">
					<header>
						<ul class="breadcrumb"><!-- breadcrumb -->
							<li><a href="/">Home</a></li>
							<li><a href="/docs/">Docs</a></li>
							<li class="active">Modularity, Composition and Hierarchy<a href="https://github.com/akkadotnet/getakka.net/edit/master/src/docs/streams/modularitycomposition.md" > (Edit on Github)</a></li>
						</ul><!-- /breadcrumb -->

						<h2><!-- Page Title -->
							<strong>Akka.NET</strong> Docs
						</h2><!-- /Page Title -->

					</header>

				</div>
			</section>
			<!-- /PAGE TOP -->

			<!-- CONTENT -->
			<section>
				<div class="container">

					<div class="row">

						<!-- RIGHT COLUMNS -->
						<div class="col-md-3" id="toc">
						</div>
						<!-- /RIGHT COLUMNS -->

						<!-- LEFT COLUMNS -->
						<div class="col-md-8 docs-content">
							<div id="main_content">

								<div><p>Akka Streams provide a uniform model of stream processing graphs, which allows flexible composition of reusable components. In this chapter we show how these look like from the conceptual and API perspective, demonstrating the modularity aspects of the library.</p>
<h1 id="basics-of-composition-and-modularity">Basics of composition and modularity</h1>
<p>Every processing stage used in Akka Streams can be imagined as a &quot;box&quot; with input and output ports where elements to be processed arrive and leave the stage. In this view, a <code>Source</code> is nothing else than a &quot;box&quot; with a single output port, or, a <code>BidiFlow</code> is a &quot;box&quot; with exactly two input and two output ports. In the figure below we illustrate the most common used stages viewed as &quot;boxes&quot;.</p>
<p><img class="img-responsive" src="../images/compose_shapes.png" alt="Composed Shapes"></p>
<p>The <em>linear</em> stages are <code>Source</code>, <code>Sink</code> and <code>Flow</code>, as these can be used to compose strict chains of processing stages.
Fan-in and Fan-out stages have usually multiple input or multiple output ports, therefore they allow to build
more complex graph layouts, not just chains. <code>BidiFlow</code> stages are usually useful in IO related tasks, where
there are input and output channels to be handled. Due to the specific shape of <code>BidiFlow</code> it is easy to
stack them on top of each other to build a layered protocol for example. The <code>TLS</code> support in Akka is for example
implemented as a <code>BidiFlow</code>.</p>
<p>These reusable components already allow the creation of complex processing networks. What we
have seen so far does not implement modularity though. It is desirable for example to package up a larger graph entity into
a reusable component which hides its internals only exposing the ports that are meant to the users of the module
to interact with. One good example is the <code>Http</code> server component, which is encoded internally as a
<code>BidiFlow</code> which interfaces with the client TCP connection using an input-output port pair accepting and sending
<code>ByteString</code> s, while its upper ports emit and receive <code>HttpRequest</code> and <code>HttpResponse</code> instances.</p>
<p>The following figure demonstrates various composite stages, that contain various other type of stages internally, but
hiding them behind a <em>shape</em> that looks like a <code>Source</code>, <code>Flow</code>, etc.</p>
<p><img class="img-responsive" src="../images/compose_composites.png" alt="Composed composites"></p>
<p>One interesting example above is a <code>Flow</code> which is composed of a disconnected <code>Sink</code> and <code>Source</code>.
This can be achieved by using the <code>FromSinkAndSource()</code> constructor method on <code>Flow</code> which takes the two parts as parameters.</p>
<p>The example <code>BidiFlow</code> demonstrates that internally a module can be of arbitrary complexity, and the exposed
ports can be wired in flexible ways. The only constraint is that all the ports of enclosed modules must be either
connected to each other, or exposed as interface ports, and the number of such ports needs to match the requirement
of the shape, for example a <code>Source</code> allows only one exposed output port, the rest of the internal ports must
be properly connected.</p>
<p>These mechanics allow arbitrary nesting of modules. For example the following figure demonstrates a <code>RunnableGraph</code>
that is built from a composite <code>Source</code> and a composite <code>Sink</code> (which in turn contains a composite <code>Flow</code>).</p>
<p><img class="img-responsive" src="../images/compose_nested_flow.png" alt="Compose nested flow"></p>
<p>The above diagram contains one more shape that we have not seen yet, which is called <code>RunnableGraph</code>. It turns
out, that if we wire all exposed ports together, so that no more open ports remain, we get a module that is <em>closed</em>.
This is what the <code>RunnableGraph</code> class represents. This is the shape that a <code>Materializer</code> can take
and turn into a network of running entities that perform the task described. In fact, a <code>RunnableGraph</code> is a
module itself, and (maybe somewhat surprisingly) it can be used as part of larger graphs. It is rarely useful to embed
a closed graph shape in a larger graph (since it becomes an isolated island as there are no open port for communication
with the rest of the graph), but this demonstrates the uniform underlying model.</p>
<p>If we try to build a code snippet that corresponds to the above diagram, our first try might look like this:</p>
<pre><code class="hljs lang-csharp">Source.Single(<span class="hljs-number">0</span>)
    .Select(x =&gt; x + <span class="hljs-number">1</span>)
    .Where(x =&gt; x != <span class="hljs-number">0</span>)
    .Select(x =&gt; x - <span class="hljs-number">2</span>)
    .To(Sink.Aggregate&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">0</span>, (sum, x) =&gt; sum + x));
</code></pre>
<p>It is clear however that there is no nesting present in our first attempt, since the library cannot figure out
where we intended to put composite module boundaries, it is our responsibility to do that. If we are using the
DSL provided by the <code>Flow</code>, <code>Source</code>, <code>Sink</code> classes then nesting can be achieved by calling one of the
methods <code>WithAttributes()</code> or <code>Named()</code> (where the latter is just a shorthand for adding a name attribute).</p>
<p>The following code demonstrates how to achieve the desired nesting:</p>
<pre><code class="hljs lang-csharp"><span class="hljs-keyword">var</span> nestedSource = 
    Source.Single(<span class="hljs-number">0</span>) <span class="hljs-comment">// An atomic source</span>
    .Select(x =&gt; x + <span class="hljs-number">1</span>) <span class="hljs-comment">// an atomic processing stage</span>
    .Named(<span class="hljs-string">"nestedSource"</span>); <span class="hljs-comment">// wraps up the current Source and gives it a name</span>

<span class="hljs-keyword">var</span> nestedFlow =
    Flow.Create&lt;<span class="hljs-keyword">int</span>&gt;().Where(x =&gt; x != <span class="hljs-number">0</span>) <span class="hljs-comment">// an atomic processing stage</span>
        .Select(x =&gt; x - <span class="hljs-number">2</span>) <span class="hljs-comment">// another atomic processing stage</span>
        .Named(<span class="hljs-string">"nestedFlow"</span>); <span class="hljs-comment">// wraps up the Flow, and gives it a name</span>

<span class="hljs-keyword">var</span> nestedSink = nestedFlow
    .To(Sink.Aggregate&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">0</span>, (sum, x) =&gt; sum + x)) <span class="hljs-comment">// wire an atomic sink to the nestedFlow</span>
    .Named(<span class="hljs-string">"nestedSink"</span>); <span class="hljs-comment">// wrap it up</span>

<span class="hljs-comment">// Create a RunnableGraph</span>
<span class="hljs-keyword">var</span> runnableGraph = nestedSource.To(nestedSink);
</code></pre>
<p>Once we have hidden the internals of our components, they act like any other built-in component of similar shape. If
we hide some of the internals of our composites, the result looks just like if any other predefine component has been
used:</p>
<p><img class="img-responsive" src="../images/compose_nested_flow_opaque.png" alt="Compose nested flow opaque"></p>
<p>If we look at usage of built-in components, and our custom components, there is no difference in usage as the code
snippet below demonstrates.</p>
<pre><code class="hljs lang-csharp"><span class="hljs-comment">// Create a RunnableGraph</span>
<span class="hljs-keyword">var</span> runnableGraph = nestedSource.To(nestedSink);

<span class="hljs-comment">// Usage is uniform, no matter if modules are composite or atomic</span>
<span class="hljs-keyword">var</span> runnableGraph2 = Source.Single(<span class="hljs-number">0</span>).To(Sink.Aggregate&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">0</span>, (sum, x) =&gt; sum + x));
</code></pre>
<h1 id="composing-complex-systems">Composing complex systems</h1>
<p>In the previous section we explored the possibility of composition, and hierarchy, but we stayed away from non-linear,
generalized graph components. There is nothing in Akka Streams though that enforces that stream processing layouts
can only be linear. The DSL for <code>Source</code> and friends is optimized for creating such linear chains, as they are
the most common in practice. There is a more advanced DSL for building complex graphs, that can be used if more
flexibility is needed. We will see that the difference between the two DSLs is only on the surface: the concepts they
operate on are uniform across all DSLs and fit together nicely.</p>
<p>As a first example, let&#39;s look at a more complex layout:</p>
<p><img class="img-responsive" src="../images/compose_graph.png" alt="Compose graph"></p>
<p>The diagram shows a <code>RunnableGraph</code> (remember, if there are no unwired ports, the graph is closed, and therefore
can be materialized) that encapsulates a non-trivial stream processing network. It contains fan-in, fan-out stages,
directed and non-directed cycles. The <code>Runnable()</code> method of the <code>GraphDSL</code> object allows the creation of a
general, closed, and runnable graph. For example the network on the diagram can be realized like this:</p>
<pre><code class="hljs lang-csharp">RunnableGraph.FromGraph(GraphDsl.Create(builder =&gt;
{
    <span class="hljs-keyword">var</span> a = builder.Add(Source.Single(<span class="hljs-number">0</span>)).Outlet;
    <span class="hljs-keyword">var</span> b = builder.Add(<span class="hljs-keyword">new</span> Broadcast&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));
    <span class="hljs-keyword">var</span> c = builder.Add(<span class="hljs-keyword">new</span> Merge&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));
    <span class="hljs-keyword">var</span> d = builder.Add(Flow.Create&lt;<span class="hljs-keyword">int</span>&gt;().Select(x =&gt; x + <span class="hljs-number">1</span>));
    <span class="hljs-keyword">var</span> e = builder.Add(<span class="hljs-keyword">new</span> Balance&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));
    <span class="hljs-keyword">var</span> f = builder.Add(<span class="hljs-keyword">new</span> Merge&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));
    <span class="hljs-keyword">var</span> g = builder.Add(Sink.ForEach&lt;<span class="hljs-keyword">int</span>&gt;(Console.WriteLine)).Inlet;

    builder.To(c).From(f);
    builder.From(a).Via(b).Via(c).To(f);
    builder.From(b).Via(d).Via(e).To(f);
    builder.From(e).To(g);

    <span class="hljs-keyword">return</span> ClosedShape.Instance;
}));
</code></pre>
<p>In the code above we used the implicit port numbering feature (to make the graph more readable and similar to the diagram)
and we imported <code>Source</code> s, <code>Sink</code> s and <code>Flow</code> s explicitly. It is possible to refer to the ports
explicitly, and it is not necessary to import our linear stages via <code>Add()</code>, so another version might look like this:</p>
<pre><code class="hljs lang-csharp">RunnableGraph.FromGraph(GraphDsl.Create(builder =&gt;
{
    <span class="hljs-keyword">var</span> b = builder.Add(<span class="hljs-keyword">new</span> Broadcast&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));
    <span class="hljs-keyword">var</span> c = builder.Add(<span class="hljs-keyword">new</span> Merge&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));
    <span class="hljs-keyword">var</span> e = builder.Add(<span class="hljs-keyword">new</span> Balance&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));
    <span class="hljs-keyword">var</span> f = builder.Add(<span class="hljs-keyword">new</span> Merge&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));

    builder.To(c.In(<span class="hljs-number">0</span>)).From(f.Out);

    builder.From(Source.Single(<span class="hljs-number">0</span>)).To(b.In);
    builder.From(b.Out(<span class="hljs-number">0</span>)).To(c.In(<span class="hljs-number">1</span>));
    builder.From(c.Out).To(f.In(<span class="hljs-number">0</span>));

    builder.From(b.Out(<span class="hljs-number">1</span>)).Via(Flow.Create&lt;<span class="hljs-keyword">int</span>&gt;().Select(x =&gt; x + <span class="hljs-number">1</span>)).To(e.In);
    builder.From(e.Out(<span class="hljs-number">0</span>)).To(f.In(<span class="hljs-number">1</span>));

    <span class="hljs-keyword">var</span> sink = Sink.ForEach&lt;<span class="hljs-keyword">int</span>&gt;(Console.WriteLine)
        .MapMaterializedValue(_ =&gt; NotUsed.Instance);
    builder.From(e.Out(<span class="hljs-number">1</span>)).To(sink);

    <span class="hljs-keyword">return</span> ClosedShape.Instance;
}));
</code></pre>
<p>Similar to the case in the first section, so far we have not considered modularity. We created a complex graph, but
the layout is flat, not modularized. We will modify our example, and create a reusable component with the graph DSL.
The way to do it is to use the <code>Create()</code> factory method on <code>GraphDSL</code>. If we remove the sources and sinks
from the previous example, what remains is a partial graph:</p>
<p><img class="img-responsive" src="../images/compose_graph_partial.png" alt="Compose partial graph"></p>
<p>We can recreate a similar graph in code, using the DSL in a similar way than before:</p>
<pre><code class="hljs lang-csharp"><span class="hljs-keyword">var</span> <span class="hljs-keyword">partial</span> = GraphDsl.Create(builder =&gt;
{
    <span class="hljs-keyword">var</span> b = builder.Add(<span class="hljs-keyword">new</span> Broadcast&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));
    <span class="hljs-keyword">var</span> c = builder.Add(<span class="hljs-keyword">new</span> Merge&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));
    <span class="hljs-keyword">var</span> e = builder.Add(<span class="hljs-keyword">new</span> Balance&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));
    <span class="hljs-keyword">var</span> f = builder.Add(<span class="hljs-keyword">new</span> Merge&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));

    builder.To(c).From(f);
    builder.From(b).Via(c).To(f);
    builder.From(b).Via(Flow.Create&lt;<span class="hljs-keyword">int</span>&gt;().Select(x =&gt; x + <span class="hljs-number">1</span>)).Via(e).To(f);

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FlowShape&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(b.In, e.Out(<span class="hljs-number">1</span>));
}).Named(<span class="hljs-string">"partial"</span>);
</code></pre>
<p>The only new addition is the return value of the builder block, which is a <code>Shape</code>. All graphs (including
<code>Source</code>, <code>BidiFlow</code>, etc) have a shape, which encodes the <em>typed</em> ports of the module. In our example
there is exactly one input and output port left, so we can declare it to have a <code>FlowShape</code> by returning an
instance of it. While it is possible to create new <code>Shape</code> types, it is usually recommended to use one of the
matching built-in ones.</p>
<p>The resulting graph is already a properly wrapped module, so there is no need to call <code>Named()</code> to encapsulate the graph, but
it is a good practice to give names to modules to help debugging.</p>
<p><img class="img-responsive" src="../images/compose_graph_shape.png" alt="Compose graph shape"></p>
<p>Since our partial graph has the right shape, it can be already used in the simpler, linear DSL:</p>
<pre><code class="hljs lang-csharp">Source.Single(<span class="hljs-number">0</span>).Via(<span class="hljs-keyword">partial</span>).To(Sink.Ignore&lt;<span class="hljs-keyword">int</span>&gt;());
</code></pre>
<p>It is not possible to use it as a <code>Flow</code> yet, though (i.e. we cannot call <code>.Where()</code> on it), but <code>Flow</code>
has a <code>FromGraph()</code> method that just adds the DSL to a <code>FlowShape</code>. There are similar methods on <code>Source</code>,
<code>Sink</code> and <code>BidiShape</code>, so it is easy to get back to the simpler DSL if a graph has the right shape.
For convenience, it is also possible to skip the partial graph creation, and use one of the convenience creator methods.
To demonstrate this, we will create the following graph:</p>
<p><img class="img-responsive" src="../images/compose_graph_flow.png" alt="Compose graph flow"></p>
<p>The code version of the above closed graph might look like this:</p>
<pre><code class="hljs lang-csharp"><span class="hljs-comment">// Convert the partial graph of FlowShape to a Flow to get</span>
<span class="hljs-comment">// access to the fluid DSL (for example to be able to call .Where())</span>
<span class="hljs-keyword">var</span> flow = Flow.FromGraph(<span class="hljs-keyword">partial</span>);

<span class="hljs-comment">// Simple way to create a graph backed Source</span>
<span class="hljs-keyword">var</span> source = Source.FromGraph(GraphDsl.Create(b =&gt;
{
    <span class="hljs-keyword">var</span> merge = b.Add(<span class="hljs-keyword">new</span> Merge&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));

    b.From(Source.Single(<span class="hljs-number">0</span>)).To(merge);
    b.From(Source.From(<span class="hljs-keyword">new</span>[] {<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>})).To(merge);

    <span class="hljs-comment">// Exposing exactly one output port</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SourceShape&lt;<span class="hljs-keyword">int</span>&gt;(merge.Out);
}));

<span class="hljs-comment">// Building a Sink with a nested Flow, using the fluid DSL</span>
<span class="hljs-keyword">var</span> nestedFlow = Flow.Create&lt;<span class="hljs-keyword">int</span>&gt;().Select(x =&gt; x*<span class="hljs-number">2</span>).Skip(<span class="hljs-number">10</span>).Named(<span class="hljs-string">"nestedFlow"</span>);
<span class="hljs-keyword">var</span> sink = nestedFlow.To(Sink.First&lt;<span class="hljs-keyword">int</span>&gt;());

<span class="hljs-comment">// Putting all together</span>
<span class="hljs-keyword">var</span> closed = source.Via(flow.Where(x =&gt; x &gt; <span class="hljs-number">1</span>)).To(sink);
</code></pre>
<div class="alert alert-default">
<p><strong>Note</strong><br/>
All graph builder sections check if the resulting graph has all ports connected except the exposed ones and will throw an exception if this is violated.</p>
</div>
<p>We are still in debt of demonstrating that <code>RunnableGraph</code> is a component just like any other, which can
be embedded in graphs. In the following snippet we embed one closed graph in another:</p>
<pre><code class="hljs lang-csharp"><span class="hljs-keyword">var</span> closed1 = Source.Single(<span class="hljs-number">0</span>).To(Sink.ForEach&lt;<span class="hljs-keyword">int</span>&gt;(Console.WriteLine));
<span class="hljs-keyword">var</span> closed2 = RunnableGraph.FromGraph(GraphDsl.Create(b =&gt;
{
    <span class="hljs-keyword">var</span> embeddedClosed = b.Add(closed1);
    <span class="hljs-comment">// â€¦</span>
    <span class="hljs-keyword">return</span> embeddedClosed;
}));
</code></pre>
<p>The type of the imported module indicates that the imported module has a <code>ClosedShape</code>, and so we are not
able to wire it to anything else inside the enclosing closed graph. Nevertheless, this &quot;island&quot; is embedded properly,
and will be materialized just like any other module that is part of the graph.</p>
<p>As we have demonstrated, the two DSLs are fully interoperable, as they encode a similar nested structure of &quot;boxes with
ports&quot;, it is only the DSLs that differ to be as much powerful as possible on the given abstraction level. It is possible
to embed complex graphs in the fluid DSL, and it is just as easy to import and embed a <code>Flow</code>, etc, in a larger,
complex structure.</p>
<p>We have also seen, that every module has a <code>Shape</code> (for example a <code>Sink</code> has a <code>SinkShape</code>)
independently which DSL was used to create it. This uniform representation enables the rich composability of various
stream processing entities in a convenient way.</p>
<h1 id="materialized-values">Materialized values</h1>
<p>After realizing that <code>RunnableGraph</code> is nothing more than a module with no unused ports (it is an island), it becomes clear that
after materialization the only way to communicate with the running stream processing logic is via some side-channel.
This side channel is represented as a <em>materialized value</em>. The situation is similar to <code>Actor</code>&#39;s, where the
<code>Props</code> instance describes the actor logic, but it is the call to <code>ActorOf()</code> that creates an actually running
actor, and returns an <code>IActorRef</code> that can be used to communicate with the running actor itself. Since the
<code>Props</code> can be reused, each call will return a different reference.</p>
<p>When it comes to streams, each materialization creates a new running network corresponding to the blueprint that was
encoded in the provided <code>RunnableGraph</code>. To be able to interact with the running network, each materialization
needs to return a different object that provides the necessary interaction capabilities. In other words, the
<code>RunnableGraph</code> can be seen as a factory, which creates:</p>
<ul>
<li>a network of running processing entities, inaccessible from the outside</li>
<li>a materialized value, optionally providing a controlled interaction capability with the network</li>
</ul>
<p>Unlike actors though, each of the processing stages might provide a materialized value, so when we compose multiple
stages or modules, we need to combine the materialized value as well (there are default rules which make this easier,
for example <code>To()</code> and <code>Via()</code> takes care of the most common case of taking the materialized value to the left.
See <a href="basics#combining-materialized-values">Combining materialized values</a> for details). We demonstrate how this works by a code example and a diagram which graphically demonstrates what is happening.</p>
<p>The propagation of the individual materialized values from the enclosed modules towards the top will look like this:</p>
<p><img class="img-responsive" src="../images/compose_mat.png" alt="Compose materialized"></p>
<p>To implement the above, first, we create a composite <code>Source</code>, where the enclosed <code>Source</code> have a
materialized type of <code>Task&lt;NotUsed&gt;</code>. By using the combiner function <code>Keep.Left</code>, the resulting materialized
type is of the nested module (indicated by the color <em>red</em> on the diagram):</p>
<pre><code class="hljs lang-csharp"><span class="hljs-comment">// Materializes to TaskCompletionSource&lt;int&gt;      (red)</span>
<span class="hljs-keyword">var</span> source = Source.Maybe&lt;<span class="hljs-keyword">int</span>&gt;();

<span class="hljs-comment">// Materializes to NotUsed                        (black)</span>
<span class="hljs-keyword">var</span> flow = Flow.Create&lt;<span class="hljs-keyword">int</span>&gt;().Take(<span class="hljs-number">100</span>);

<span class="hljs-comment">// Materializes to TaskCompletionSource&lt;int&gt;      (red)</span>
<span class="hljs-keyword">var</span> nestedSource = source.ViaMaterialized(flow, Keep.Left).Named(<span class="hljs-string">"nestedSource"</span>);
</code></pre>
<p>Next, we create a composite <code>Flow</code> from two smaller components. Here, the second enclosed <code>Flow</code> has a
materialized type of <code>Task&lt;OutgoingConnection&gt;</code>, and we propagate this to the parent by using <code>Keep.Right</code>
as the combiner function (indicated by the color <em>yellow</em> on the diagram):</p>
<pre><code class="hljs lang-csharp"><span class="hljs-comment">// Materializes to NotUsed                      (orange)  </span>
<span class="hljs-keyword">var</span> flow1 = Flow.Create&lt;<span class="hljs-keyword">int</span>&gt;().Select(x =&gt; ByteString.FromString(x.ToString()));

<span class="hljs-comment">// Materializes to Task&lt;OutgoingConnection&gt;     (yellow)  </span>
<span class="hljs-keyword">var</span> flow2 = Sys.TcpStream().OutgoingConnection(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">8080</span>);

<span class="hljs-comment">// Materializes to Task&lt;OutgoingConnection&gt;     (yellow)  </span>
<span class="hljs-keyword">var</span> nestedFlow = flow1.ViaMaterialized(flow2, Keep.Right).Named(<span class="hljs-string">"nestedFlow"</span>);
</code></pre>
<p>As a third step, we create a composite <code>Sink</code>, using our <code>nestedFlow</code> as a building block. In this snippet, both
the enclosed <code>Flow</code> and the folding <code>Sink</code> has a materialized value that is interesting for us, so
we use <code>Keep.Both</code> to get a <code>Tuple</code> of them as the materialized type of <code>nestedSink</code> (indicated by the color
<em>blue</em> on the diagram)</p>
<pre><code class="hljs lang-csharp"><span class="hljs-comment">// Materializes to Task&lt;String&gt;                                 (green)</span>
<span class="hljs-keyword">var</span> sink = Sink.Aggregate&lt;ByteString, <span class="hljs-keyword">string</span>&gt;(<span class="hljs-string">""</span>, (agg, s) =&gt; agg + s.DecodeString());

<span class="hljs-comment">// Materializes to (Task&lt;OutgoingConnection&gt;, Task&lt;String&gt;)     (blue)</span>
<span class="hljs-keyword">var</span> nestedSink = nestedFlow.ToMaterialized(sink, Keep.Both);
</code></pre>
<p>As the last example, we wire together <code>nestedSource</code> and <code>nestedSink</code> and we use a custom combiner function to
create a yet another materialized type of the resulting <code>RunnableGraph</code>. This combiner function just ignores
the <code>Task[Sink]</code> part, and wraps the other two values in a custom case class <code>MyClass</code> (indicated by color <em>purple</em> on the diagram):</p>
<pre><code class="hljs lang-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>
{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> TaskCompletionSource&lt;<span class="hljs-keyword">int</span>&gt; _completion;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> Tcp.OutgoingConnection _connection;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params">TaskCompletionSource&lt;<span class="hljs-keyword">int</span>&gt; completion, Tcp.OutgoingConnection connection</span>)
    </span>{
        _completion = completion;
        _connection = connection;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Close</span>(<span class="hljs-params"></span>) </span>=&gt; _completion.SetResult(<span class="hljs-number">1</span>);
}

<span class="hljs-comment">// Materializes to Task&lt;MyClass&gt;        (purple)</span>
<span class="hljs-keyword">var</span> runnableGraph = nestedSource.ToMaterialized(nestedSink, (completion, rest) =&gt;
{
    <span class="hljs-keyword">var</span> connectionTask = rest.Item1;
    <span class="hljs-keyword">return</span> connectionTask.ContinueWith(task =&gt; <span class="hljs-keyword">new</span> MyClass(completion, task.Result));
});
</code></pre>
<div class="alert alert-default">
<p><strong>Note</strong><br/>
The nested structure in the above example is not necessary for combining the materialized values, it just demonstrates how the two features work together. See <a href="basics#combining-materialized-values">Combining materialized values</a> for further examples of combining materialized values without nesting and hierarchy involved.</p>
</div>
<h1 id="attributes">Attributes</h1>
<p>We have seen that we can use <code>Named()</code> to introduce a nesting level in the fluid DSL (and also explicit nesting by using
<code>Create()</code> from :class:<code>GraphDSL</code>). Apart from having the effect of adding a nesting level, <code>Named()</code> is actually
a shorthand for calling <code>WithAttributes(Attributes.CreateName(&quot;someName&quot;))</code>. Attributes provide a way to fine-tune certain
aspects of the materialized running entity. For example buffer sizes for asynchronous stages can be controlled via
attributes (<a href="buffersandworkingwithrate#buffers-for-asynchronous-stages">see</a>). When it comes to hierarchic composition, attributes are inherited by nested modules, unless they override them with a custom value.</p>
<p>The code below, a modification of an earlier example sets the <code>InputBuffer</code> attribute on certain modules, but not
on others:</p>
<pre><code class="hljs lang-csharp"><span class="hljs-keyword">var</span> nestedSource = Source.Single(<span class="hljs-number">0</span>)
    .Select(x =&gt; x + <span class="hljs-number">1</span>)
    .Named(<span class="hljs-string">"nestedSource"</span>); <span class="hljs-comment">// Wrap, no inputBuffer set</span>

<span class="hljs-keyword">var</span> nestedFlow =
    Flow.Create&lt;<span class="hljs-keyword">int</span>&gt;()
        .Where(x =&gt; x != <span class="hljs-number">0</span>)
        .Via(Flow.Create&lt;<span class="hljs-keyword">int</span>&gt;().Select(x =&gt; x - <span class="hljs-number">2</span>).WithAttributes(Attributes.CreateInputBuffer(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>)))
        <span class="hljs-comment">// override</span>
        .Named(<span class="hljs-string">"nestedFlow"</span>); <span class="hljs-comment">// Wrap, no inputBuffer set</span>

<span class="hljs-keyword">var</span> nestedSink = nestedFlow
    .To(Sink.Aggregate&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">0</span>, (sum, i) =&gt; sum + i)) <span class="hljs-comment">// wire an atomic sink to the nestedFlow</span>
    .WithAttributes(Attributes.CreateName(<span class="hljs-string">"nestedSink"</span>).And(Attributes.CreateInputBuffer(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>))); <span class="hljs-comment">// override</span>
</code></pre>
<p>The effect is, that each module inherits the <code>InputBuffer</code> attribute from its enclosing parent, unless it has
the same attribute explicitly set. <code>nestedSource</code> gets the default attributes from the materializer itself. <code>nestedSink</code>
on the other hand has this attribute set, so it will be used by all nested modules. <code>nestedFlow</code> will inherit from <code>nestedSink</code>
except the <code>Select</code> stage which has again an explicitly provided attribute overriding the inherited one.</p>
<p><img class="img-responsive" src="../images/compose_attributes.png" alt="Composed Attributes"></p>
<p>This diagram illustrates the inheritance process for the example code (representing the materializer default attributes
as the color <em>red</em>, the attributes set on <code>nestedSink</code> as <em>blue</em> and the attributes set on <code>nestedFlow</code> as <em>green</em>).</p>
</div>

								

						</div>
						<div class="col-md-1">&nbsp;</div>
						<!-- /LEFT COLUMNS -->



					</div>

				</div>
			</section>
			<!-- /CONTENT -->

			<footer id="footer">
  <div class="container">
    <div class="row">
        <!-- col #1 -->
        <div class="spaced dark col-md-3">
            <h4>About <strong>Akka.NET</strong></h4>
            <p class="block">
                Akka.NET is a port of the popular
                <br/> Java/Scala framework <a href="http://akka.io">Akka</a> to .NET.
                <br/>
                <br/> This is a community driven port and
                <br/> is not affiliated with <a href="http://typesafe.com">Typesafe</a> who
                <br/> makes the original Java/Scala version.
                <br/>
            </p>
            <!-- social -->
            <p class="block">
                <a href="mailto:hi@getakka.net">hi@getakka.net</a><br>
                <a href="https://www.facebook.com/akkadotnet" class="social fa fa-facebook"></a>
                <a href="http://stackoverflow.com/questions/tagged/akka.net" class="social fa fa-stack-overflow"></a>
                <a href="https://twitter.com/AkkaDotNET" class="social fa fa-twitter"></a>
            </p><!-- /social -->
        </div>
        <!-- /col #1 -->
        <!-- col #3 -->
        <div class="spaced col-md-6 col-sm-4">
            <h4>Recent <strong>Tweets</strong></h4>
            <ul class="list-unstyled fsize13" id="recent_tweets">
            </ul>
        </div>
        <!-- /col #3 -->
        <div class="spaced col-md-3 col-sm-4">
            <h4>Keep <strong>Updated</strong></h4>
            <h4><small><strong>Subscribe to our Newsletter</strong></small></h4>
            <!-- Begin MailChimp Signup Form -->
<div id="mc_embed_signup">
    <form class="input-group" action="//github.us8.list-manage.com/subscribe/post?u=945d2a2edaa89aaabd396bc45&amp;id=5f9a7a993d" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
        <input type="email" value="" name="EMAIL" class="form-control placeholder required email" id="mce-EMAIL" placeholder="E-mail Address">
        <span class="input-group-btn">
  <button class="btn btn-primary" type="submit" name="subscribe" id="mc-embedded-subscribe">SUBMIT</button>
</span>
        <div id="mce-responses" class="clear">
            <div class="response" id="mce-error-response" style="display:none"></div>
            <div class="response" id="mce-success-response" style="display:none"></div>
        </div>
        <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
        <div style="position: absolute; left: -5000px;">
            <input type="text" name="b_945d2a2edaa89aaabd396bc45_5f9a7a993d" tabindex="-1" value="">
        </div>
        <div class="clear"></div>
    </form>
</div>
<!--End mc_embed_signup-->

        </div>
    </div>
  </div>
  <hr />
  <!-- <div class="copyright">
    <div class="container text-center fsize12"></div>
  </div> -->
</footer>


			<a href="#" id="toTop"></a>

		</div><!-- /#wrapper -->

		<script type="text/javascript" src="/theme_assets/plugins/jquery-2.1.1.min.js"></script>
<script type="text/javascript" src="/theme_assets/plugins/jquery.isotope.js"></script>
<script type="text/javascript" src="/theme_assets/plugins/masonry.js"></script>
<script type="text/javascript" src="/theme_assets/plugins/bootstrap/js/bootstrap.min.js"></script>
<script type="text/javascript" src="/theme_assets/plugins/magnific-popup/jquery.magnific-popup.min.js"></script>
<script type="text/javascript" src="/theme_assets/plugins/owl-carousel/owl.carousel.min.js"></script>
<script type="text/javascript" src="/theme_assets/plugins/knob/js/jquery.knob.js"></script>
<script type="text/javascript" src="/theme_assets/plugins/flexslider/jquery.flexslider-min.js"></script>

<!-- REVOLUTION SLIDER -->
<script type="text/javascript" src="/theme_assets/plugins/revolution-slider/js/jquery.themepunch.plugins.min.js"></script>
<script type="text/javascript" src="/theme_assets/plugins/revolution-slider/js/jquery.themepunch.revolution.min.js"></script>
<script type="text/javascript" src="/theme_assets/js/revolution_slider.js"></script>
<script type="text/javascript" src="/js/jquery-toc.js"></script>
<script type="text/javascript" src="/theme_assets/js/scripts.js"></script>
<script type="text/javascript" src="/js/scripts.js"></script>
		<!-- REACTIVE MANIFESTO BANNER -->
<a href="http://www.reactivemanifesto.org/"> <img style="border: 0; position: fixed; right: 0; top:0; z-index: 9000; max-width: 125px;" src="//d379ifj7s9wntv.cloudfront.net/reactivemanifesto/images/ribbons/we-are-reactive-red-right.png"> </a>

	</body>
</html>
