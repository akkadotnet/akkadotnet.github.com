<!DOCTYPE html>
<!--[if IE 8]>			<html class="ie ie8"> <![endif]-->
<!--[if IE 9]>			<html class="ie ie9"> <![endif]-->
<!--[if gt IE 9]><!-->	<html> <!--<![endif]-->
	<head>
		

<meta charset="utf-8" />
<title>FSharp API | Akka.NET</title>

<meta name="keywords" content="Actor,Finite state machine, concurrency" />
<meta name="description" content="" />
<meta name="Author" content="Dorin Grigoras [www.stepofweb.com]" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />

<!-- mobile settings -->
<meta name="viewport" contenht="width=device-width, maximum-scale=1, initial-scale=1, user-scalable=0" />

<!-- Favicon -->
<link rel="shortcut icon" href="/theme_assets/images/demo/favicon.ico" />

<!-- WEB FONTS -->
<link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,700,800&amp;subset=latin,latin-ext" rel="stylesheet" type="text/css" />

<!-- CORE CSS -->
<link href="/theme_assets/plugins/bootstrap/css/bootstrap.min.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/font-awesome.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/sky-forms.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/weather-icons.min.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/line-icons.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/plugins/owl-carousel/owl.pack.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/plugins/magnific-popup/magnific-popup.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/animate.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/flexslider.css" rel="stylesheet" type="text/css" />

<!-- FAV ICON -->
<link rel="shortcut icon" href="http://akkadotnet.github.io/favicon.ico?v=2" />

<!-- REVOLUTION SLIDER -->
<link href="/theme_assets/css/revolution-slider.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/layerslider.css" rel="stylesheet" type="text/css" />

<!-- BLOG -->
<link href="/theme_assets/css/layout-blog.css" rel="stylesheet" type="text/css" />

<!-- THEME CSS -->
<link href="/theme_assets/css/essentials.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/layout.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/header-default.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/footer-default.css" rel="stylesheet" type="text/css" />
<link href="/theme_assets/css/color_scheme/red.css" rel="stylesheet" type="text/css" id="color_scheme" />

<!-- Highlighting -->
<link href="https://highlightjs.org/static/demo/styles/github.css" rel="stylesheet" type="text/css" />
<link href="/css/screen.css" rel="stylesheet" type="text/css" />

<!-- Modernizr -->
<script type="text/javascript" src="/theme_assets/plugins/modernizr.min.js"></script>

<!--[if lte IE 8]>
  <script src="/theme_assets/plugins/respond.js"></script>
<![endif]-->

	</head>

	<!--
		Available body classes:
			smoothscroll			= enable chrome browser smooth scroll
			grey 					= grey content background
			boxed 					= boxed style
			pattern1 ... pattern10 	= background pattern

		Background Image - add to body:
			data-background="/theme_assets/images/boxed_background/1.jpg"
	-->
	<body class=" smoothscroll">

		<div id="wrapper">
			<div id="header">
  <header id="topBar">
    <div class="container">

      

      <!-- Logo -->
      <a class="logo" href="/">
        <img src="/images/akkalogo.png"  alt="" style="padding-top:0px;padding-left: 5px;" />
      </a>

    </div><!-- /.container -->
  </header>
  <div id="topNav">
  <div class="container">
    <!-- Mobile Menu Button -->
    <button class="btn btn-mobile" data-toggle="collapse" data-target=".nav-main-collapse">
      <i class="fa fa-bars"></i>
    </button>

    <!-- Search -->
    <form class="search" method="get" action="/search">
      <input type="text" class="form-control" name="q" value="" placeholder="Search">
      <button class="fa fa-search"></button>
    </form>
    <!-- /Search -->

    <!-- Top Nav -->
    <div class="navbar-collapse nav-main-collapse collapse inline-block">
      <nav class="nav-main">

      

        <!-- pageurl  -->
        <ul id="topMain" class="nav nav-pills nav-main">
          <li class="mega-menu  active">
            <a href="/docs/">DOCUMENTATION<span>&nbsp;</span></a>
          </li>
          <li class="mega-menu">
            <a href="https://github.com/akkadotnet/akka.net/">CODE<span>&nbsp;</span></a>
          </li>
          <li class="mega-menu">
            <a href="https://gitter.im/akkadotnet/akka.net">PROJECT CHAT<span>&nbsp;</span></a>
          </li>
          <li class="mega-menu">
            <a href="https://groups.google.com/forum/#!forum/akkadotnet-user-list">MAILING LIST<span>&nbsp;</span></a>
          </li>
          <li class="mega-menu ">
            <a href="/pages/support">COMMERCIAL SUPPORT<span>&nbsp;</span></a>
          </li>
          <li class="mega-menu ">
            <a href="/docs/Resources">RESOURCES<span>&nbsp;</span></a>
          </li>
        </ul>

      </nav>
    </div>
</div>
</div>
			

			<!-- PAGE TOP -->
			<section class="page-title">
				<div class="container">
					<header>
						<ul class="breadcrumb"><!-- breadcrumb -->
							<li><a href="/">Home</a></li>
							<li><a href="/docs/">Docs</a></li>
							<li class="active">FSharp API<a href="https://github.com/akkadotnet/getakka.net/edit/master/src/docs/FSharp API.md" > (Edit on Github)</a></li>
						</ul><!-- /breadcrumb -->

						<h2><!-- Page Title -->
							<strong>Akka.NET</strong> Docs
						</h2><!-- /Page Title -->

					</header>

				</div>
			</section>
			<!-- /PAGE TOP -->

			<!-- CONTENT -->
			<section>
				<div class="container">

					<div class="row">

						<!-- RIGHT COLUMNS -->
						<div class="col-md-3" id="toc">
						</div>
						<!-- /RIGHT COLUMNS -->

						<!-- LEFT COLUMNS -->
						<div class="col-md-8 docs-content">
							<div id="main_content">

								<div><h1 id="akka-net-f-api">Akka.NET F# API</h1>
<h3 id="actor-system-and-configuration">Actor system and configuration</h3>
<p>Unlike default (C#) actor system, F#-aware systems should be created using <code>Akka.FSharp.System.create</code> function. This function differs from it&#39;s C# equivalent by providing additional F#-specific features - i.e. serializers allowing to serialize F# quotations for remote deployment process.</p>
<p>Example:</p>
<pre><code class="hljs lang-fsharp"><span class="hljs-keyword">open</span> Akka.FSharp
<span class="hljs-keyword">use</span> system = System.create <span class="hljs-string">"my-system"</span> (Configuration.load())
</code></pre>
<p>F# also gives you it&#39;s own actor system Configuration module with support of following functions:</p>
<ul>
<li><code>defaultConfig() : Config</code> - returns default F# Akka configuration.</li>
<li><code>parse(hoconString : string) : Config</code> - parses a provided Akka configuration string.</li>
<li><code>load() : Config</code> - loads an Akka configuration found inside current project&#39;s <em>.config</em> file.</li>
</ul>
<h3 id="creating-actors-with-actor-computation-expression">Creating actors with <code>actor</code> computation expression</h3>
<p>Unlike C# actors, which represent object oriented nature of the language, F# is able to define an actor&#39;s logic in more functional way. It is done by using <code>actor</code> computation expression. In most of the cases, an expression inside <code>actor</code> is expected to be represented as self-invoking recursive function - also invoking an other functions while maintaining recursive cycle is allowed, i.e. to change actor&#39;s behavior or even to create more advanced constructs like Finite State Machines.</p>
<p>It&#39;s important to remember, that each actor returning point should point to the next recursive function call - any other value returned will result in stopping the current actor (see: <a href="Actor lifecycle">Actor Lifecycle</a>).</p>
<p>Example:</p>
<pre><code class="hljs lang-fsharp"><span class="hljs-keyword">let</span> aref =
    spawn system <span class="hljs-string">"my-actor"</span>
        (<span class="hljs-keyword">fun</span> mailbox -&gt;
            <span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> loop() = actor {
                <span class="hljs-keyword">let!</span> message = mailbox.Receive()
                <span class="hljs-comment">// handle an incoming message</span>
                <span class="hljs-keyword">return!</span> loop()
            }
            loop())
</code></pre>
<p>Since the construct used in the above example is quite popular, you may also use the following shorthand functions to define the message handler&#39;s behavior:</p>
<ul>
<li><code>actorOf (fn : &#39;Message -&gt; unit) (mailbox : Actor&lt;&#39;Message&gt;) : Cont&lt;&#39;Message, &#39;Returned&gt;</code> - uses a function, which takes a message as the only parameter. Mailbox parameter is injected by spawning functions.</li>
<li><code>actorOf2 (fn : Actor&lt;&#39;Message&gt; -&gt; &#39;Message -&gt; unit) (mailbox : Actor&lt;&#39;Message&gt;) : Cont&lt;&#39;Message, &#39;Returned&gt;</code> - uses a function, which takes both the message and an Actor instance as the parameters. Mailbox parameter is injected by spawning functions.</li>
</ul>
<p>Example:</p>
<pre><code class="hljs lang-fsharp"><span class="hljs-keyword">let</span> handleMessage (mailbox: Actor&lt;<span class="hljs-attribute">'a</span>&gt;) msg =
    <span class="hljs-keyword">match</span> msg <span class="hljs-keyword">with</span>
    | Some x -&gt; printf <span class="hljs-string">"%A"</span> x
    | None -&gt; ()

<span class="hljs-keyword">let</span> aref = spawn system <span class="hljs-string">"my-actor"</span> (actorOf2 handleMessage)
<span class="hljs-keyword">let</span> blackHole = spawn system <span class="hljs-string">"black-hole"</span> (actorOf (<span class="hljs-keyword">fun</span> msg -&gt; ()))
</code></pre>
<h4 id="spawning-actors">Spawning actors</h4>
<p>The above paragraph has already shown how actors may be created with the help of a spawning function. There are several spawning functions, which may be used to instantiate actors:</p>
<ul>
<li><code>spawn (actorFactory : IActorRefFactory) (name : string) (f : Actor&lt;&#39;Message&gt; -&gt; Cont&lt;&#39;Message, &#39;Returned&gt;) : IActorRef</code> - spawns an actor using a specified actor computation expression. The actor can only be used locally.</li>
<li><code>spawnOpt (actorFactory : IActorRefFactory) (name : string) (f : Actor&lt;&#39;Message&gt; -&gt; Cont&lt;&#39;Message, &#39;Returned&gt;) (options : SpawnOption list) : IActorRef</code> - spawns an actor using a  specified actor computation expression, with custom spawn option settings. The actor can only be used locally.</li>
<li><code>spawne (actorFactory : IActorRefFactory) (name : string) (expr : Expr&lt;Actor&lt;&#39;Message&gt; -&gt; Cont&lt;&#39;Message, &#39;Returned&gt;&gt;) (options : SpawnOption list) : IActorRef</code> - spawns an actor using a  specified actor computation expression, using an Expression AST. The actor code can be deployed remotely.</li>
<li><code>spawnObj (actorFactory : IActorRefFactory) (name : string) (f : Quotations.Expr&lt;(unit -&gt; #ActorBase)&gt;) : IActorRef</code> - spawns an actor using a specified actor quotation. The actor can only be used locally.</li>
<li><code>spawnObjOpt (actorFactory : IActorRefFactory) (name : string) (f : Quotations.Expr&lt;(unit -&gt; #ActorBase)&gt;) (options : SpawnOption list) : IActorRef</code> - spawns an actor using a specified actor quotation, with custom spawn option settings. The actor can only be used locally.</li>
</ul>
<p>All of these functions may be used with either the actor system or the actor itself. In the first case the spawned actor will be placed under <em>/user</em> root guardian of the current actor system hierarchy. In the second option the spawned actor will become a child of the actor used as the  <code>actorFactory</code> parameter of the spawning function.</p>
<h4 id="dealing-with-disposable-resources">Dealing with disposable resources</h4>
<p>When executing application logic inside the receive function, be aware of a constant threat of stopping a current actor at any time for various reasons. This is an especially problematic situation when you are using a resource allocation - when an actor stops suddenly, you may be left with potentially heavy resources still waiting to be released.</p>
<p>Use <code>mailbox.Defer (deferredFunc)</code> in situations when you must ensure operation to be executed at the end of the actor lifecycle.</p>
<p>Example:</p>
<pre><code class="hljs lang-fsharp"><span class="hljs-keyword">let</span> disposableActor (mailbox:Actor&lt;_&gt;) =
    <span class="hljs-keyword">let</span> resource = <span class="hljs-keyword">new</span> DisposableResource()
    mailbox.Defer ((resource :&gt; IDisposable).Dispose)
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> loop () =
        actor {
            <span class="hljs-keyword">let!</span> msg = mailbox.Receive()
            <span class="hljs-keyword">return!</span> loop ()
        }
    loop()
</code></pre>
<h3 id="actor-spawning-options">Actor spawning options</h3>
<p>To be able to specify more precise actor creation behavior, you may use <code>spawnOpt</code> and <code>spawne</code> methods, both taking a list of <code>SpawnOption</code> values. Each specific option should be present only once in the collection. When a conflict occurs (more than one option of specified type has been found), the latest value found inside the list will be chosen.</p>
<ul>
<li><code>SpawnOption.Deploy(Akka.Actor.Deploy)</code> - defines deployment strategy for created actors (see: [[Deploy]]). This option may be used along with <code>spawne</code> function to enable remote actors deployment.</li>
<li><code>SpawnOption.Router(Akka.Routing.RouterConfig)</code> - defines an actor to be a router as well as it&#39;s routing specifics (see: <a href="Routing">Routing</a>).</li>
<li><code>SpawnOption.SupervisiorStrategy(Akka.Actor.SupervisiorStrategy)</code> - defines a supervisor strategy of the current actor. It will affect its children (see: <a href="Supervision">Supervision</a>).</li>
<li><code>SpawnOption.Dispatcher(string)</code> - defines a type of the dispatcher used for resources management for the created actors. (See: <a href="Dispatchers">Dispatchers</a>)</li>
<li><code>SpawnOption.Mailbox(string)</code> - defines a type of the mailbox used for the created actors. (See: <a href="Mailbox">Mailboxes</a>)</li>
</ul>
<p>Example (deploy actor remotely):</p>
<pre><code class="hljs lang-fsharp"><span class="hljs-keyword">open</span> Akka.Actor
<span class="hljs-keyword">let</span> remoteRef =
    spawne system <span class="hljs-string">"my-actor"</span> &lt;@ actorOf myFunc @&gt;
        [SpawnOption.Deploy (Deploy(RemoteScope(Address.Parse <span class="hljs-string">"akka.tcp://remote-system@127.0.0.1:9000/"</span>)))]
</code></pre>
<h3 id="ask-and-tell-operators">Ask and tell operators</h3>
<p>While you may use traditional <code>IActorRef.Tell</code> and <code>IActorRef.Ask</code> methods, it&#39;s more convenient to use dedicated <code>&lt;!</code> and <code>&lt;?</code> operators to perform related operations.</p>
<p>Example:</p>
<pre><code class="hljs lang-fsharp">aref &lt;! message
async { <span class="hljs-keyword">let!</span> response = aref &lt;? request }
</code></pre>
<h3 id="actor-selection">Actor selection</h3>
<p>Actors may be referenced not only by <code>IActorRef</code>s, but also through actor path selection (see: <a href="Addressing">Addressing</a>). With the F# API you may select an actor with a known path using the <code>select</code> function:</p>
<ul>
<li><code>select (path : string) (selector : IActorRefFactory) : ActorSelection</code> - where path is a valid URI string used to recognize an actor path, and the selector is either an actor system or an actor itself.</li>
</ul>
<p>Example:</p>
<pre><code class="hljs lang-fsharp"><span class="hljs-keyword">let</span> aref = spawn system <span class="hljs-string">"my-actor"</span> (actorOf2 (<span class="hljs-keyword">fun</span> mailbox m -&gt; printfn <span class="hljs-string">"%A said %s"</span> (mailbox.Self.Path) m))
aref &lt;! <span class="hljs-string">"one"</span>
<span class="hljs-keyword">let</span> aref2 = select <span class="hljs-string">"akka://my-system/user/my-actor"</span> system
aref2 &lt;! <span class="hljs-string">"two"</span>
</code></pre>
<h3 id="inboxes">Inboxes</h3>
<p>Inboxes are actor-like objects used to listen to other actors. They are a good choice to watch over other actors lifecycle. Some of the inbox-related functions may block current thread and therefore should not be used inside actors.</p>
<ul>
<li><code>inbox (system : ActorSystem) : Inbox</code> - creates a new inbox in provided actor system scope.</li>
<li><code>receive (timeout : TimeSpan) (i : Inbox) : &#39;Message option</code> - receives a next message sent to the inbox. This is a blocking operation. Returns <code>None</code> if timeout occurred or message is incompatible with expected response type.</li>
<li><code>filterReceive (timeout : TimeSpan) (predicate : &#39;Message -&gt; bool) (i : Inbox) : &#39;Message option</code> - receives a next message sent to the inbox, which satisfies provided predicate. This is a blocking operation. Returns <code>None</code> if timeout occurred or message is incompatible with expected response type.</li>
<li><code>asyncReceive (i : Inbox) : Async&lt;&#39;Message option&gt;</code> - Awaits in async block for a next message sent to the inbox. Returns <code>None</code> if message is incompatible with expected response type.</li>
</ul>
<p>Inboxes may be configured to accept a limited number of incoming messages (default is 1000):</p>
<pre><code class="hljs lang-hocon">akka {
    actor {
        inbox {
            inbox-size = <span class="hljs-number">30</span>
        }
    }
}
</code></pre>
<h3 id="monitoring">Monitoring</h3>
<p>Actors and Inboxes may be used to monitor lifetime of other actors. This is done by <code>monitor</code>/<code>demonitor</code> functions:</p>
<ul>
<li><code>monitor (subject: IActorRef) (watcher: ICanWatch) : IActorRef</code> - starts monitoring a referred actor.</li>
<li><code>demonitor (subject: IActorRef) (watcher: ICanWatch) : IActorRef</code> - stops monitoring of the previously monitored actor.</li>
</ul>
<p>Monitored actors will automatically send a <code>Terminated</code> message to their watchers when they die.</p>
<h3 id="actor-supervisor-strategies">Actor supervisor strategies</h3>
<p>Actors have a place in their system&#39;s hierarchy trees. To manage failures done by the child actors, their parents/supervisors may decide to use specific supervisor strategies (see: <a href="Supervision">Supervision</a>) in order to react to the specific types of errors. In F# this may be configured using functions of the <code>Strategy</code> module:</p>
<ul>
<li><code>Strategy.OneForOne (decider : exn -&gt; Directive) : SupervisorStrategy</code> - returns a supervisor strategy applicable only to child actor which faulted during execution.</li>
<li><code>Strategy.OneForOne (decider : exn -&gt; Directive, ?retries : int, ?timeout : TimeSpan) : SupervisorStrategy</code> - returns a supervisor strategy applicable only to child actor which faulted during execution. The <code>retries</code> parameter defines a number of times an actor could be restarted. If it&#39;s a negative value, there is no limit. The <code>timeout</code> parameter defines a time window for the  number of retries to occur.</li>
<li><code>OneForOne (decider : Expr&lt;(exn -&gt; Directive)&gt;, ?retries : int, ?timeout : TimeSpan)  : SupervisorStrategy</code> - returns a supervisor strategy applicable only to child actor which faulted during execution. The <code>retries</code> parameter defines a number of times an actor could be restarted. If it&#39;s a negative value, there is no limit. The <code>timeout</code> parameter defines a time window for the number of retries to occur. <strong>Strategies created this way may be serialized and deserialized on remote nodes</strong> .</li>
<li><code>Strategy.AllForOne (decider : exn -&gt; Directive) : SupervisorStrategy</code> - returns a supervisor strategy applicable to each supervised actor when any of them had faulted during execution.</li>
<li><code>Strategy.AllForOne (decider : exn -&gt; Directive, ?retries : int, ?timeout : TimeSpan) : SupervisorStrategy</code> -  returns a supervisor strategy applicable to each supervised actor when any of them had faulted during execution. The <code>retries</code> parameter defines a number of times an actor could be restarted. If it&#39;s a negative value, there is no limit. The <code>timeout</code> parameter defines a time window for the number of retries to occur.</li>
<li><code>AllForOne (decider : Expr&lt;(exn -&gt; Directive)&gt;, ?retries : int, ?timeout : TimeSpan) : SupervisorStrategy</code> - returns a supervisor strategy applicable to each supervised actor when any of them had faulted during execution. The <code>retries</code> parameter defines a number of times an actor could be restarted. If it&#39;s a negative value, there is no limit. The <code>timeout</code> parameter defines a time window for the number of retries to occur. <strong>Strategies created this way may be serialized and deserialized on remote nodes</strong> .</li>
</ul>
<p>Example:</p>
<pre><code class="hljs lang-fsharp"><span class="hljs-keyword">let</span> aref =
    spawnOpt system <span class="hljs-string">"my-actor"</span> (actorOf myFunc)
        [ SpawnOption.SupervisorStrategy (Strategy.OneForOne (<span class="hljs-keyword">fun</span> error -&gt;
            <span class="hljs-keyword">match</span> error <span class="hljs-keyword">with</span>
            | :? ArithmeticException -&gt; Directive.Escalate
            | _ -&gt; SupervisorStrategy.DefaultDecider error )) ]

<span class="hljs-keyword">let</span> remoteRef =
    spawne system <span class="hljs-string">"remote-actor"</span> &lt;@ actorOf myFunc @&gt;
        [ SpawnOption.SupervisorStrategy (Strategy.OneForOne &lt;@ <span class="hljs-keyword">fun</span> error -&gt;
            <span class="hljs-keyword">match</span> error <span class="hljs-keyword">with</span>
            | :? ArithmeticException -&gt; Directive.Escalate
            | _ -&gt; SupervisorStrategy.DefaultDecider error ) @&gt;
          SpawnOption.Deploy (Deploy (RemoteScope remoteNodeAddr)) ]
</code></pre>
<h3 id="publish-subscribe-support">Publish/Subscribe support</h3>
<p>While you may use built-in set of the event stream methods (see: [Event Streams]), there is an option of using the dedicated F# API functions:</p>
<ul>
<li><code>subscribe (channel: System.Type) (ref: IActorRef) (eventStream: Akka.Event.EventStream) : bool</code> - subscribes an actor reference to the target channel of the provided event stream. Channels are associated with specific types of a message emitted by the publishers.</li>
<li><code>unsubscribe (channel: System.Type) (ref: IActorRef) (eventStream: Akka.Event.EventStream) : bool</code> - unsubscribes an actor reference from the target channel of the provided event stream.</li>
<li><code>publish (event: &#39;Event) (eventStream: Akka.Event.EventStream) : unit</code> - publishes an event on the provided event stream. Event channel is resolved from event&#39;s type.</li>
</ul>
<p>Example:</p>
<pre><code class="hljs lang-fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Message</span> </span>=
    | Subscribe
    | Unsubscribe
    | Msg <span class="hljs-keyword">of</span> ActorRef * string

<span class="hljs-keyword">let</span> subscriber =
    spawn system <span class="hljs-string">"subscriber"</span>
        (actorOf2 (<span class="hljs-keyword">fun</span> mailbox msg -&gt;
            <span class="hljs-keyword">let</span> eventStream = mailbox.Context.System.EventStream
            <span class="hljs-keyword">match</span> msg <span class="hljs-keyword">with</span>
            | Msg (sender, content) -&gt; printfn <span class="hljs-string">"%A says %s"</span> (sender.Path) content
            | Subscribe -&gt; subscribe typeof&lt;Message&gt; mailbox.Self eventStream |&gt; ignore
            | Unsubscribe -&gt; unsubscribe typeof&lt;Message&gt; mailbox.Self eventStream |&gt; ignore ))

<span class="hljs-keyword">let</span> publisher =
    spawn system <span class="hljs-string">"publisher"</span>
        (actorOf2 (<span class="hljs-keyword">fun</span> mailbox msg -&gt;
            publish msg mailbox.Context.System.EventStream))

subscriber &lt;! Subscribe
publisher  &lt;! Msg (publisher, <span class="hljs-string">"hello"</span>)
subscriber &lt;! Unsubscribe
publisher  &lt;! Msg (publisher, <span class="hljs-string">"hello again"</span>)
</code></pre>
<h3 id="logging">Logging</h3>
<p>The F# API supports two groups of logging functions - one that operates directly on strings and another (which may be recognized by <em>f</em> suffix in function names) that operates using F# string formatting features. The major difference is performance - the former is less powerful, but it&#39;s also faster than the latter.</p>
<p>Both groups support logging on various levels (DEBUG, &lt;default&gt; INFO, WARNING and ERROR). Actor system&#39;s logging level may be managed through configuration, i.e.:</p>
<pre><code class="hljs lang-hocon"><span class="hljs-title">akka</span> {
    <span class="hljs-title">actor</span> {
        <span class="hljs-comment"># collection of loggers used inside actor system, specified by fully-qualified type name</span>
        <span class="hljs-title">loggers</span> = [ <span class="hljs-string">"Akka.Event.DefaultLogger, Akka"</span> ]

        <span class="hljs-comment"># Options: OFF, ERROR, WARNING, INFO, DEBUG</span>
        loglevel = <span class="hljs-string">"DEBUG"</span>
    }
}
</code></pre>
<p>F# API provides following logging methods:</p>
<ul>
<li><code>log (level : LogLevel) (mailbox : Actor&lt;&#39;Message&gt;) (msg : string) : unit</code>, <code>logf (level : LogLevel) (mailbox : Actor&lt;&#39;Message&gt;) (format:StringFormat&lt;&#39;T, &#39;Result&gt;) : &#39;T</code> - both functions takes an <code>Akka.Event.LogLevel</code> enum parameter to specify log level explicitly.</li>
<li><code>logDebug</code>, <code>logDebugf</code> - message will be logged at Debug level.</li>
<li><code>logInfo</code>, <code>logInfof</code> - message will be logged at Info level.</li>
<li><code>logWarning</code>, <code>logWarningf</code> - message will be logged at Warning level.</li>
<li><code>logError</code>, <code>logError</code> - message will be logged at Error level.</li>
<li><code>logException (mailbox: Actor&lt;&#39;a&gt;) (e : exn) : unit</code> - this function logs a message from provided <code>System.Exception</code> object at the Error level.</li>
</ul>
<h3 id="interop-with-task-parallel-library">Interop with Task Parallel Library</h3>
<p>Since both TPL and Akka frameworks can be used for parallel processing, sometimes they need to work both inside the same application.</p>
<p>To operate directly between <code>Async</code> results and actors, use <code>pipeTo</code> function (and its abbreviations in the form of <code>&lt;!|</code> and <code>|!&gt;</code> operators) to inform actor about tasks ending their processing pipelines. Piping functions used on tasks will move async result directly to the mailbox of a target actor.</p>
<p>Example:</p>
<pre><code class="hljs lang-fsharp"><span class="hljs-keyword">open</span> System.IO
<span class="hljs-keyword">let</span> handler (mailbox: Actor&lt;obj&gt;) msg =
    <span class="hljs-keyword">match</span> box msg <span class="hljs-keyword">with</span>
    | :? FileInfo <span class="hljs-keyword">as</span> fi -&gt;
        <span class="hljs-keyword">let</span> reader = <span class="hljs-keyword">new</span> StreamReader(fi.OpenRead())
        reader.AsyncReadToEnd() |!&gt; mailbox.Self
    | :? string <span class="hljs-keyword">as</span> content -&gt;
        printfn <span class="hljs-string">"File content: %s"</span> content
    | _ -&gt; mailbox.Unhandled()

<span class="hljs-keyword">let</span> aref = spawn system <span class="hljs-string">"my-actor"</span> (actorOf2 handler)
aref &lt;! <span class="hljs-keyword">new</span> FileInfo <span class="hljs-string">"Akka.xml"</span>
</code></pre>
</div>

								

						</div>
						<div class="col-md-1">&nbsp;</div>
						<!-- /LEFT COLUMNS -->



					</div>

				</div>
			</section>
			<!-- /CONTENT -->

			<footer id="footer">
  <div class="container">
    <div class="row">
        <!-- col #1 -->
        <div class="spaced dark col-md-3">
            <h4>About <strong>Akka.NET</strong></h4>
            <p class="block">
                Akka.NET is a port of the popular
                <br/> Java/Scala framework <a href="http://akka.io">Akka</a> to .NET.
                <br/>
                <br/> This is a community driven port and
                <br/> is not affiliated with <a href="http://typesafe.com">Typesafe</a> who
                <br/> makes the original Java/Scala version.
                <br/>
            </p>
            <!-- social -->
            <p class="block">
                <a href="mailto:hi@getakka.net">hi@getakka.net</a><br>
                <a href="https://www.facebook.com/akkadotnet" class="social fa fa-facebook"></a>
                <a href="http://stackoverflow.com/questions/tagged/akka.net" class="social fa fa-stack-overflow"></a>
                <a href="https://twitter.com/AkkaDotNET" class="social fa fa-twitter"></a>
            </p><!-- /social -->
        </div>
        <!-- /col #1 -->
        <!-- col #3 -->
        <div class="spaced col-md-6 col-sm-4">
            <h4>Recent <strong>Tweets</strong></h4>
            <ul class="list-unstyled fsize13" id="recent_tweets">
            </ul>
        </div>
        <!-- /col #3 -->
        <div class="spaced col-md-3 col-sm-4">
            <h4>Keep <strong>Updated</strong></h4>
            <h4><small><strong>Subscribe to our Newsletter</strong></small></h4>
            <!-- Begin MailChimp Signup Form -->
<div id="mc_embed_signup">
    <form class="input-group" action="//github.us8.list-manage.com/subscribe/post?u=945d2a2edaa89aaabd396bc45&amp;id=5f9a7a993d" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
        <input type="email" value="" name="EMAIL" class="form-control placeholder required email" id="mce-EMAIL" placeholder="E-mail Address">
        <span class="input-group-btn">
  <button class="btn btn-primary" type="submit" name="subscribe" id="mc-embedded-subscribe">SUBMIT</button>
</span>
        <div id="mce-responses" class="clear">
            <div class="response" id="mce-error-response" style="display:none"></div>
            <div class="response" id="mce-success-response" style="display:none"></div>
        </div>
        <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
        <div style="position: absolute; left: -5000px;">
            <input type="text" name="b_945d2a2edaa89aaabd396bc45_5f9a7a993d" tabindex="-1" value="">
        </div>
        <div class="clear"></div>
    </form>
</div>
<!--End mc_embed_signup-->

        </div>
    </div>
  </div>
  <hr />
  <!-- <div class="copyright">
    <div class="container text-center fsize12"></div>
  </div> -->
</footer>


			<a href="#" id="toTop"></a>

		</div><!-- /#wrapper -->

		<script type="text/javascript" src="/theme_assets/plugins/jquery-2.1.1.min.js"></script>
<script type="text/javascript" src="/theme_assets/plugins/jquery.isotope.js"></script>
<script type="text/javascript" src="/theme_assets/plugins/masonry.js"></script>
<script type="text/javascript" src="/theme_assets/plugins/bootstrap/js/bootstrap.min.js"></script>
<script type="text/javascript" src="/theme_assets/plugins/magnific-popup/jquery.magnific-popup.min.js"></script>
<script type="text/javascript" src="/theme_assets/plugins/owl-carousel/owl.carousel.min.js"></script>
<script type="text/javascript" src="/theme_assets/plugins/knob/js/jquery.knob.js"></script>
<script type="text/javascript" src="/theme_assets/plugins/flexslider/jquery.flexslider-min.js"></script>

<!-- REVOLUTION SLIDER -->
<script type="text/javascript" src="/theme_assets/plugins/revolution-slider/js/jquery.themepunch.plugins.min.js"></script>
<script type="text/javascript" src="/theme_assets/plugins/revolution-slider/js/jquery.themepunch.revolution.min.js"></script>
<script type="text/javascript" src="/theme_assets/js/revolution_slider.js"></script>
<script type="text/javascript" src="/js/jquery-toc.js"></script>
<script type="text/javascript" src="/theme_assets/js/scripts.js"></script>
<script type="text/javascript" src="/js/scripts.js"></script>
		<!-- REACTIVE MANIFESTO BANNER -->
<a href="http://www.reactivemanifesto.org/"> <img style="border: 0; position: fixed; right: 0; top:0; z-index: 9000; max-width: 125px;" src="//d379ifj7s9wntv.cloudfront.net/reactivemanifesto/images/ribbons/we-are-reactive-red-right.png"> </a>

	</body>
</html>
