<h1 id="akka-net-f-api">Akka.NET F# API</h1>
<h3 id="actor-system-and-configuration">Actor system and configuration</h3>
<p>Unlike default (C#) actor system, F#-aware systems should be created using <code>Akka.FSharp.System.create</code> function. This function differs from it&#39;s C# equivalent by providing additional F#-specific features - i.e. serializers allowing to serialize F# quotations for remote deployment process.</p>
<p>Example:</p>
<pre><code><span class="hljs-built_in">open</span> Akka.FSharp
use <span class="hljs-keyword">system</span> = System.<span class="hljs-built_in">create</span> <span class="hljs-string">"my-system"</span> (Configuration.<span class="hljs-built_in">load</span>())
</code></pre><p>F# also gives you it&#39;s own actor system Configuration module with support of following functions:</p>
<ul>
<li><code>defaultConfig() : Config</code> - returns default F# Akka configuration.</li>
<li><code>parse(hoconString : string) : Config</code> - parses a provided Akka configuration string.</li>
<li><code>load() : Config</code> - loads an Akka configuration found inside current project&#39;s <em>.config</em> file.</li>
</ul>
<h3 id="creating-actors-with-actor-computation-expression">Creating actors with <code>actor</code> computation expression</h3>
<p>Unlike C# actors, which represent object oriented nature of the language, F# is able to define an actor&#39;s logic in more functional way. It is done by using <code>actor</code> computation expression. In most of the cases, an expression inside <code>actor</code> is expected to be represented as self-invoking recursive function - also invoking an other functions while maintaining recursive cycle is allowed, i.e. to change actor&#39;s behavior or even to create more advanced constructs like Finite State Machines. </p>
<p>It&#39;s important to remember, that each actor returning point should point to the next recursive function call - any other value returned will result in stopping current actor (see: <a href="http://akkadotnet.github.io/wiki/Actor%20lifecycle">Actor Lifecycle</a>).</p>
<p>Example:</p>
<pre><code><span class="hljs-keyword">let</span> aref = 
    spawn system <span class="hljs-string">"my-actor"</span> 
        (fun mailbox -&gt; 
            <span class="hljs-keyword">let</span> rec <span class="hljs-keyword">loop</span>() = actor {
                <span class="hljs-keyword">let</span>! message = mailbox.Receive()
                <span class="hljs-comment">// handle an incoming message</span>
                <span class="hljs-keyword">return</span>! <span class="hljs-keyword">loop</span>()
            }
            <span class="hljs-keyword">loop</span>())
</code></pre><p>Since construct used in an example above is quite popular, you may also use following shorthand functions to define message handler&#39;s behavior:</p>
<ul>
<li><code>actorOf (fn : &#39;Message -&gt; unit) (mailbox : Actor&lt;&#39;Message&gt;) : Cont&lt;&#39;Message, &#39;Returned&gt;</code> - uses a function, which takes a message as the only parameter. Mailbox parameter is injected by spawning functions.</li>
<li><code>actorOf2 (fn : Actor&lt;&#39;Message&gt; -&gt; &#39;Message -&gt; unit) (mailbox : Actor&lt;&#39;Message&gt;) : Cont&lt;&#39;Message, &#39;Returned&gt;</code> - uses a function, which takes both the message and an Actor instance as the parameters. Mailbox parameter is injected by spawning functions.</li>
</ul>
<p>Example:</p>
<pre><code><span class="hljs-keyword">let</span> handleMessage (mailbox: Actor&lt;'a&gt;) msg =
    <span class="hljs-keyword">match</span> msg with
    | Some x -&gt; printf <span class="hljs-string">"%A"</span> x
    | None -&gt; ()

<span class="hljs-keyword">let</span> aref = spawn system <span class="hljs-string">"my-actor"</span> (actorOf2 handleMessage)
<span class="hljs-keyword">let</span> blackHole = spawn system <span class="hljs-string">"black-hole"</span> (actorOf (fun msg -&gt; ()))
</code></pre><h4 id="spawning-actors">Spawning actors</h4>
<p>Paragraph above already has shown, how actors may be created with help of the spawning function. There are several spawning function, which may be used to instantiate actors:</p>
<ul>
<li><code>spawn (actorFactory : ActorRefFactory) (name : string) (f : Actor&lt;&#39;Message&gt; -&gt; Cont&lt;&#39;Message, &#39;Returned&gt;) : ActorRef</code> - spawns an actor using specified actor computation expression. The actor can only be used locally. </li>
<li><code>spawnOpt (actorFactory : ActorRefFactory) (name : string) (f : Actor&lt;&#39;Message&gt; -&gt; Cont&lt;&#39;Message, &#39;Returned&gt;) (options : SpawnOption list) : ActorRef</code> - spawns an actor using specified actor computation expression, with custom spawn option settings. The actor can only be used locally. </li>
<li><code>spawne (actorFactory : ActorRefFactory) (name : string) (expr : Expr&lt;Actor&lt;&#39;Message&gt; -&gt; Cont&lt;&#39;Message, &#39;Returned&gt;&gt;) (options : SpawnOption list) : ActorRef</code> - spawns an actor using specified actor computation expression, using an Expression AST. The actor code can be deployed remotely.</li>
</ul>
<p>All of these functions may be used with either actor system or actor itself. In the first case spawned actor will be placed under <em>/user</em> root guardian of the current actor system hierarchy. In second option spawned actor will become child of the actor used as [actorFactory] parameter of the spawning function.</p>
<h3 id="actor-spawning-options">Actor spawning options</h3>
<p>To be able to specifiy more precise actor creation behavior, you may use <code>spawnOpt</code> and <code>spawne</code> methods, both taking a list of <code>SpawnOption</code> values. Each specific option should be present only once in the collection. When a conflict occurs (more than one option of specified type has been found), the latest value found inside the list will be chosen.</p>
<ul>
<li><code>SpawnOption.Deploy(Akka.Actor.Deploy)</code> - defines deployment strategy for created actors (see: Deploy). This option may be used along with <code>spawne</code> function to enable remote actors deployment.</li>
<li><code>SpawnOption.Router(Akka.Routing.RouterConfig)</code> - defines an actor to be a router as well as it&#39;s routing specifics (see: <a href="http://akkadotnet.github.io/wiki/Routing">Routing</a>).</li>
<li><code>SpawnOption.SupervisiorStrategy(Akka.Actor.SupervisiorStrategy)</code> - defines a supervisor strategy of the current actor. It will affect it&#39;s children (see: <a href="http://akkadotnet.github.io/wiki/Supervision">Supervision</a>).</li>
<li><code>SpawnOption.Dispatcher(string)</code> - defines a type of the dispatcher used for resources management for the created actors. (See: <a href="http://akkadotnet.github.io/wiki/Dispatchers">Dispatchers</a>)</li>
<li><code>SpawnOption.Mailbox(string)</code> - defines a type of the mailbox used for the created actors. (See: <a href="http://akkadotnet.github.io/wiki/Mailbox">Mailboxes</a>)</li>
</ul>
<p>Example (deploy actor remotely):</p>
<pre><code><span class="hljs-keyword">open</span> Akka.Actor
<span class="hljs-keyword">let</span> remoteRef = 
    spawne <span class="hljs-built_in">system</span> <span class="hljs-string">"my-actor"</span> &lt;@ actorOf myFunc @&gt; 
        [SpawnOption.Deploy (Deploy(RemoteScope(Address.Parse <span class="hljs-string">"akka.tcp://remote-system@127.0.0.1:9000/"</span>)))]
</code></pre><h3 id="ask-and-tell-operators">Ask and tell operators</h3>
<p>While you may use traditional <code>ActorRef.Tell</code> and <code>ActorRef.Ask</code> methods, it&#39;s more convenient to use dedicated <code>&lt;!</code> and <code>&lt;?</code> operators to perform related operations.</p>
<p>Example:</p>
<pre><code>aref &lt;! message
async { <span class="hljs-keyword">let</span>! <span class="hljs-built_in">response</span> = aref &lt;? <span class="hljs-built_in">request</span> }
</code></pre><h3 id="actor-selection">Actor selection</h3>
<p>Actors may be referenced not only by <code>ActorRef</code>s, but also through actor path selection (see: <a href="http://akkadotnet.github.io/wiki/Addressing">Addressing</a>). With F# API you may select an actor with known path using <code>select</code> function:</p>
<ul>
<li><code>select (path : string) (selector : ActorRefFactory) : ActorSelection</code> - where path is a valid URI string used to recognize actor path, and the selector is either actor system or actor itself.</li>
</ul>
<p>Example:</p>
<pre><code>let aref = spawn <span class="hljs-keyword">system</span> <span class="hljs-string">"my-actor"</span> (actorOf2 (fun mailbox <span class="hljs-keyword">m</span> -&gt; printfn <span class="hljs-string">"<span class="hljs-variable">%A</span> said <span class="hljs-variable">%s</span>"</span> (mailbox.Self.Path) <span class="hljs-keyword">m</span>))
aref &lt;! <span class="hljs-string">"one"</span>
let aref2 = <span class="hljs-keyword">select</span> <span class="hljs-string">"akka://my-system/user/my-actor"</span> <span class="hljs-keyword">system</span>
aref2 &lt;! <span class="hljs-string">"two"</span>
</code></pre><h3 id="inboxes">Inboxes</h3>
<p>Inboxes are actor-like objects used to be listened by other actors. They are a good choice to watch over other actors lifecycle. Some of the inbox-related functions may block current thread and therefore should not be used inside actors.</p>
<ul>
<li><code>inbox (system : ActorSystem) : Inbox</code> - creates a new inbox in provided actor system scope.</li>
<li><code>receive (timeout : TimeSpan) (i : Inbox) : &#39;Message option</code> - receives a next message sent to the inbox. This is a blocking operation. Returns <code>None</code> if timeout occurred or message is incompatible with expected response type.</li>
<li><code>filterReceive (timeout : TimeSpan) (predicate : &#39;Message -&gt; bool) (i : Inbox) : &#39;Message option</code> - receives a next message sent to the inbox, which satisfies provided predicate. This is a blocking operation. Returns <code>None</code> if timeout occurred or message is incompatible with expected response type.</li>
<li><code>asyncReceive (i : Inbox) : Async&lt;&#39;Message option&gt;</code> - Awaits in async block for a next message sent to the inbox. Returns <code>None</code> if message is incompatible with expected response type.</li>
</ul>
<p>Inboxes may be configured to accept a limited number of incoming messages (default is 1000):</p>
<pre><code><span class="hljs-attribute">akka {
    actor {
        inbox {
            inbox-size </span>=<span class="hljs-string"> 30
        }
    }
}</span>
</code></pre><h3 id="monitoring">Monitoring</h3>
<p>Actors and Inboxes may be used to monitor lifetime of other actors. This is done by <code>monitor</code>/<code>demonitor</code> functions:</p>
<ul>
<li><code>monitor (subject: ActorRef) (watcher: ICanWatch) : ActorRef</code> - starts monitoring a referred actor.</li>
<li><code>demonitor (subject: ActorRef) (watcher: ICanWatch) : ActorRef</code> - stops monitoring of the previously monitored actor.</li>
</ul>
<p>Monitored actors will automatically send a <code>Terminated</code> message to their watchers when they die.</p>
<h3 id="actor-supervisor-strategies">Actor supervisor strategies</h3>
<p>Actors have a place in their system&#39;s hierarchy trees. To manage failures done by the child actors, their parents/supervisors may decide to use specific supervisor strategies (see: <a href="http://akkadotnet.github.io/wiki/Supervision">Supervision</a>) in order to react to the specific types of errors. In F# this may be configured using functions of the <code>Strategy</code> module:</p>
<ul>
<li><code>Strategy.oneForOne (decider : exn -&gt; Directive) : SupervisorStrategy</code> - returns a supervisor strategy applicable only to child actor which faulted during execution.</li>
<li><code>Strategy.oneForOne2 (retries : int) (timeout : TimeSpan) (decider : exn -&gt; Directive) : SupervisorStrategy</code> - returns a supervisor strategy applicable only to child actor which faulted during execution. [retries] param defines a number of times, an actor could be restarted. If it&#39;s a negative value, there is not limit. [timeout] param defines a time window for number of retries to occur.</li>
<li><code>Strategy.allForOne (decider : exn -&gt; Directive) : SupervisorStrategy</code> - returns a supervisor strategy applicable to each supervised actor when any of them had faulted during execution.</li>
<li><code>Strategy.allForOne2 (retries : int) (timeout : TimeSpan) (decider : exn -&gt; Directive) : SupervisorStrategy</code> -  returns a supervisor strategy applicable to each supervised actor when any of them had faulted during execution. [retries] param defines a number of times, an actor could be restarted. If it&#39;s a negative value, there is not limit. [timeout] param defines a time window for number of retries to occur.</li>
</ul>
<p>Example:</p>
<pre><code><span class="hljs-keyword">let</span> aref <span class="hljs-subst">=</span> 
    spawnOpt system <span class="hljs-string">"my-actor"</span> (actorOf myFunc) 
        <span class="hljs-preprocessor">[</span> SpawnOption<span class="hljs-built_in">.</span>SupervisorStrategy (Strategy<span class="hljs-built_in">.</span>oneForOne (fun error <span class="hljs-subst">-&gt; 
            </span><span class="hljs-keyword">match</span> error <span class="hljs-keyword">with</span>
            <span class="hljs-subst">|</span> :<span class="hljs-subst">?</span> ArithmeticException <span class="hljs-subst">-&gt; </span>Directive<span class="hljs-built_in">.</span>Escalate
            <span class="hljs-subst">|</span> _ <span class="hljs-subst">-&gt; </span>SupervisorStrategy<span class="hljs-built_in">.</span>DefaultDecider error )) <span class="hljs-preprocessor">]</span><span class="hljs-markup"></span>
</code></pre><h3 id="publish-subscribe-support">Publish/Subscribe support</h3>
<p>While you may use built-in set of the event stream methods (see: Event Streams), there is an option of using dedicated F# API functions:</p>
<ul>
<li><code>sub (channel: System.Type) (ref: ActorRef) (eventStream: Akka.Event.EventStream) : bool</code> - subscribes an actor reference to target channel of the provided event stream. Channels are associated with specific types of a message emitted by the publishers.</li>
<li><code>unsub (channel: System.Type) (ref: ActorRef) (eventStream: Akka.Event.EventStream) : bool</code> - unsubscribes an actor reference from target channel of the provided event stream.</li>
<li><code>pub (event: &#39;Event) (eventStream: Akka.Event.EventStream) : unit</code> - publishes an event on the provided event stream. Event channel is resolved from event&#39;s type.</li>
</ul>
<p>Example: </p>
<pre><code><span class="hljs-keyword">type</span> <span class="hljs-title">Message</span> = 
    | Subscribe 
    | Unsubscribe
    | Msg of ActorRef * string

<span class="hljs-keyword">let</span> subscriber = 
    spawn system <span class="hljs-string">"subscriber"</span> 
        (actorOf2 (fun mailbox msg -&gt; 
            <span class="hljs-keyword">let</span> eventStream = mailbox.Context.System.EventStream
            <span class="hljs-keyword">match</span> msg with
            | Msg (sender, content) -&gt; printfn <span class="hljs-string">"%A says %s"</span> (sender.Path) content
            | Subscribe -&gt; sub <span class="hljs-keyword">typeof</span>&lt;Message&gt; mailbox.Self eventStream |&gt; ignore
            | Unsubscribe -&gt; unsub <span class="hljs-keyword">typeof</span>&lt;Message&gt; mailbox.Self eventStream |&gt; ignore ))

<span class="hljs-keyword">let</span> publisher = 
    spawn system <span class="hljs-string">"publisher"</span> 
        (actorOf2 (fun mailbox msg -&gt; 
            <span class="hljs-keyword">pub</span> msg mailbox.Context.System.EventStream))

subscriber &lt;! Subscribe
publisher  &lt;! Msg (publisher, <span class="hljs-string">"hello"</span>)
subscriber &lt;! Unsubscribe
publisher  &lt;! Msg (publisher, <span class="hljs-string">"hello again"</span>)
</code></pre><h3 id="scheduling">Scheduling</h3>
<p>Akka gives you an offhand support for scheduling (see: <a href="http://akkadotnet.github.io/wiki/Scheduler">Scheduler</a>). Scheduling function can be grouped by two dimensions: </p>
<ol>
<li>Cyclic (interval) vs single time scheduling - you may decide if scheduled job should be performed repeatedly or only once.</li>
<li>Function vs message-&gt;actor scheduling - you may decide to schedule job in form of a function or a message automatically sent to target actor reference.</li>
</ol>
<p>F# API provides following scheduling functions:</p>
<ul>
<li><code>schedule (after: TimeSpan) (every: TimeSpan) (fn: unit -&gt; unit) (scheduler: Scheduler): Async&lt;unit&gt;</code> - [cyclic, function] schedules a function to be called by the scheduler repeatedly.</li>
<li><code>scheduleOnce (after: TimeSpan) (fn: unit -&gt; unit) (scheduler: Scheduler): Async&lt;unit&gt;</code> - [single, function] schedules a function to be called only once by the scheduler.</li>
<li><code>scheduleTell (after: TimeSpan) (every: TimeSpan) (message: &#39;Message) (receiver: ActorRef) (scheduler: Scheduler): Async&lt;unit&gt;</code> - [cyclic, message] schedules a message to be sent to the target actor reference by the scheduler repeatedly.</li>
<li><code>scheduleTellOnce (after: TimeSpan) (message: &#39;Message) (receiver: ActorRef) (scheduler: Scheduler): Async&lt;unit&gt;</code> - [single, message] schedules a message to be sent only once to the target actor reference, by the scheduler.</li>
</ul>
<h3 id="logging">Logging</h3>
<p>F# API supports two groups of logging functions - one that operates directly on strings and second (which may be recognized by <em>f</em> suffix in function names) which operates using F# string formating features. Major difference is performance - first one is less powerful, but it&#39;s also faster than the second one.</p>
<p>Both groups support logging on various levels (DEBUG, &lt;default&gt; INFO, WARNING and ERROR). Actor system&#39;s logging level may be managed through configuration, i.e.:</p>
<pre><code><span class="hljs-title">akka</span> {
    <span class="hljs-title">actor</span> {
        <span class="hljs-comment"># collection of loggers used inside actor system, specified by fully-qualified type name</span>
        <span class="hljs-title">loggers</span> = [ <span class="hljs-string">"Akka.Event.DefaultLogger, Akka"</span> ]

        <span class="hljs-comment"># Options: OFF, ERROR, WARNING, INFO, DEBUG</span>
        logLevel = <span class="hljs-string">"DEBUG"</span>
    }
}
</code></pre><p>F# API provides following logging methods:</p>
<ul>
<li><code>log (level : LogLevel) (mailbox : Actor&lt;&#39;Message&gt;) (msg : string) : unit</code>, <code>logf (level : LogLevel) (mailbox : Actor&lt;&#39;Message&gt;) (format:StringFormat&lt;&#39;T, &#39;Result&gt;) : &#39;T</code> - both functions takes an <code>Akka.Event.LogLevel</code> enum parameter to specify log level explicitly.</li>
<li><code>logDebug</code>, <code>logDebugf</code> - message will be logged at Debug level.</li>
<li><code>logInfo</code>, <code>logInfof</code> - message will be logged at Info level.</li>
<li><code>logWarning</code>, <code>logWarningf</code> - message will be logged at Warning level.</li>
<li><code>logError</code>, <code>logError</code> - message will be logged at Error level.</li>
<li><code>logException (mailbox: Actor&lt;&#39;a&gt;) (e : exn) : unit</code> - this function logs a message from provided <code>System.Exception</code> object at the Error level.</li>
</ul>
<h3 id="interop-with-task-parallel-library">Interop with Task Parallel Library</h3>
<p>Since both TPL an Akka frameworks can be used for parallel processing, sometimes they need to work both inside the same application.</p>
<p>To operate directly between <code>Async</code> results and actors, use <code>pipeTo</code> function (and it&#39;s abbreviations in form of <code>&lt;!|</code> and <code>|!&gt;</code> operators) to inform actor about tasks ending their processing pipelines. Piping functions used on tasks will move async result directly to the mailbox of a target actor.</p>
<p>Example:</p>
<pre><code>open System<span class="hljs-built_in">.</span>IO
<span class="hljs-keyword">let</span> handler (mailbox: Actor<span class="hljs-subst">&lt;</span>obj<span class="hljs-subst">&gt;</span>) msg <span class="hljs-subst">=</span> 
    <span class="hljs-keyword">match</span> box msg <span class="hljs-keyword">with</span>
    <span class="hljs-subst">|</span> :<span class="hljs-subst">?</span> FileInfo as fi <span class="hljs-subst">-&gt; 
        </span><span class="hljs-keyword">let</span> reader <span class="hljs-subst">=</span> <span class="hljs-literal">new</span> StreamReader(fi<span class="hljs-built_in">.</span>OpenRead())
        reader<span class="hljs-built_in">.</span>AsyncReadToEnd() <span class="hljs-subst">|!&gt;</span> mailbox<span class="hljs-built_in">.</span><span class="hljs-built_in">Self</span> 
    <span class="hljs-subst">|</span> :<span class="hljs-subst">?</span> <span class="hljs-built_in">string</span> as content <span class="hljs-subst">-&gt;
        </span>printfn <span class="hljs-string">"File content: %s"</span> content
    <span class="hljs-subst">|</span> _ <span class="hljs-subst">-&gt; </span>mailbox<span class="hljs-built_in">.</span>Unhandled()

<span class="hljs-keyword">let</span> aref <span class="hljs-subst">=</span> spawn system <span class="hljs-string">"my-actor"</span> (actorOf2 handler)
aref <span class="hljs-subst">&lt;!</span> <span class="hljs-literal">new</span> FileInfo <span class="hljs-string">"Akka.xml"</span>
</code></pre>